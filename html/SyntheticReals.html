<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>SyntheticReals</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Symbol">{-#</a> <a id="5" class="Keyword">OPTIONS</a> <a id="13" class="Pragma">--cubical</a> <a id="23" class="Pragma">--no-import-sorts</a> <a id="41" class="Pragma">--allow-unsolved-metas</a> <a id="64" class="Symbol">#-}</a>

<a id="69" class="Keyword">module</a> <a id="76" href="SyntheticReals.html" class="Module">SyntheticReals</a> <a id="91" class="Keyword">where</a>

<a id="98" class="Keyword">open</a> <a id="103" class="Keyword">import</a> <a id="110" href="Agda.Primitive.html" class="Module">Agda.Primitive</a> <a id="125" class="Keyword">renaming</a> <a id="134" class="Symbol">(</a><a id="135" href="Agda.Primitive.html#736" class="Primitive Operator">_⊔_</a> <a id="139" class="Symbol">to</a> <a id="Primitive._⊔_"></a><a id="142" href="SyntheticReals.html#142" class="Primitive Operator">ℓ-max</a><a id="147" class="Symbol">;</a> <a id="149" href="Agda.Primitive.html#706" class="Primitive">lsuc</a> <a id="154" class="Symbol">to</a> <a id="Primitive.lsuc"></a><a id="157" href="SyntheticReals.html#157" class="Primitive">ℓ-suc</a><a id="162" class="Symbol">;</a> <a id="164" href="Agda.Primitive.html#690" class="Primitive">lzero</a> <a id="170" class="Symbol">to</a> <a id="Primitive.lzero"></a><a id="173" href="SyntheticReals.html#173" class="Primitive">ℓ-zero</a><a id="179" class="Symbol">)</a>

<a id="182" class="Keyword">private</a>
  <a id="192" class="Keyword">variable</a>
    <a id="205" href="SyntheticReals.html#205" class="Generalizable">ℓ</a> <a id="207" href="SyntheticReals.html#207" class="Generalizable">ℓ&#39;</a> <a id="210" href="SyntheticReals.html#210" class="Generalizable">ℓ&#39;&#39;</a> <a id="214" class="Symbol">:</a> <a id="216" href="Agda.Primitive.html#523" class="Postulate">Level</a>

<a id="223" class="Keyword">open</a> <a id="228" class="Keyword">import</a> <a id="235" href="Cubical.Foundations.Everything.html" class="Module">Cubical.Foundations.Everything</a> <a id="266" class="Keyword">renaming</a> <a id="275" class="Symbol">(</a><a id="276" href="Cubical.Foundations.GroupoidLaws.html#311" class="Function Operator">_⁻¹</a> <a id="280" class="Symbol">to</a> <a id="Foundations.GroupoidLaws._⁻¹"></a><a id="283" href="SyntheticReals.html#283" class="Function Operator">_⁻¹ᵖ</a><a id="287" class="Symbol">;</a> <a id="289" href="Cubical.Foundations.GroupoidLaws.html#2243" class="Function">assoc</a> <a id="295" class="Symbol">to</a> <a id="Foundations.GroupoidLaws.assoc"></a><a id="298" href="SyntheticReals.html#298" class="Function">∙-assoc</a><a id="305" class="Symbol">)</a>
<a id="307" class="Keyword">open</a> <a id="312" class="Keyword">import</a> <a id="319" href="Cubical.Structures.CommRing.html" class="Module">Cubical.Structures.CommRing</a>
<a id="347" class="Keyword">open</a> <a id="352" class="Keyword">import</a> <a id="359" href="Cubical.Relation.Nullary.Base.html" class="Module">Cubical.Relation.Nullary.Base</a> <a id="389" class="Comment">-- ¬_</a>
<a id="395" class="Keyword">open</a> <a id="400" class="Keyword">import</a> <a id="407" href="Cubical.Relation.Binary.Base.html" class="Module">Cubical.Relation.Binary.Base</a>
<a id="436" class="Keyword">open</a> <a id="441" class="Keyword">import</a> <a id="448" href="Cubical.Data.Sum.Base.html" class="Module">Cubical.Data.Sum.Base</a> <a id="470" class="Keyword">renaming</a> <a id="479" class="Symbol">(</a><a id="480" href="Cubical.Data.Sum.Base.html#188" class="Datatype Operator">_⊎_</a> <a id="484" class="Symbol">to</a> <a id="487" class="Keyword">infixr</a> <a id="494" class="Number">4</a> <a id="Data.Sum.Base._⊎_"></a><a id="496" href="SyntheticReals.html#496" class="Datatype Operator">_⊎_</a><a id="499" class="Symbol">)</a>
<a id="501" class="Keyword">open</a> <a id="506" class="Keyword">import</a> <a id="513" href="Cubical.Data.Sigma.Base.html" class="Module">Cubical.Data.Sigma.Base</a> <a id="537" class="Keyword">renaming</a> <a id="546" class="Symbol">(</a><a id="547" href="Cubical.Data.Sigma.Base.html#489" class="Function Operator">_×_</a> <a id="551" class="Symbol">to</a> <a id="554" class="Keyword">infixr</a> <a id="561" class="Number">4</a> <a id="Data.Sigma.Base._×_"></a><a id="563" href="SyntheticReals.html#563" class="Function Operator">_×_</a><a id="566" class="Symbol">)</a>
<a id="568" class="Keyword">open</a> <a id="573" class="Keyword">import</a> <a id="580" href="Cubical.Data.Empty.html" class="Module">Cubical.Data.Empty</a> <a id="599" class="Keyword">renaming</a> <a id="608" class="Symbol">(</a><a id="609" href="Cubical.Data.Empty.Base.html#190" class="Function">elim</a> <a id="614" class="Symbol">to</a> <a id="Data.Empty.Base.elim"></a><a id="617" href="SyntheticReals.html#617" class="Function">⊥-elim</a><a id="623" class="Symbol">)</a> <a id="625" class="Comment">-- `⊥` and `elim`</a>
<a id="643" class="Comment">-- open import Cubical.Structures.Poset</a>
<a id="683" class="Keyword">open</a> <a id="688" class="Keyword">import</a> <a id="695" href="Cubical.Foundations.Function.html" class="Module">Cubical.Foundations.Function</a>

<a id="725" class="Keyword">open</a> <a id="730" class="Keyword">import</a> <a id="737" href="Function.Base.html" class="Module">Function.Base</a> <a id="751" class="Keyword">using</a> <a id="757" class="Symbol">(</a><a id="758" href="Function.Base.html#4458" class="Function Operator">_∋_</a><a id="761" class="Symbol">)</a>
<a id="763" class="Comment">-- open import Function.Reasoning using (∋-syntax)</a>
<a id="814" class="Keyword">open</a> <a id="819" class="Keyword">import</a> <a id="826" href="Function.Base.html" class="Module">Function.Base</a> <a id="840" class="Keyword">using</a> <a id="846" class="Symbol">(</a><a id="847" href="Function.Base.html#4708" class="Function">it</a><a id="849" class="Symbol">)</a> <a id="851" class="Comment">-- instance search</a>

<a id="871" class="Keyword">open</a> <a id="876" class="Keyword">import</a> <a id="883" href="Utils.html" class="Module">Utils</a>
<a id="889" class="Keyword">open</a> <a id="894" class="Keyword">import</a> <a id="901" href="MoreLogic.html" class="Module">MoreLogic</a>
<a id="911" class="Keyword">open</a> <a id="916" href="MoreLogic.html#720" class="Module">MoreLogic.Reasoning</a>
<a id="936" class="Keyword">open</a> <a id="941" href="MoreLogic.html#1499" class="Module">MoreLogic.Properties</a>
<a id="962" class="Keyword">open</a> <a id="967" class="Keyword">import</a> <a id="974" href="MoreAlgebra.html" class="Module">MoreAlgebra</a>
<a id="986" class="Keyword">open</a> <a id="991" href="MoreAlgebra.html#605" class="Module">MoreAlgebra.Definitions</a>
<a id="1015" class="Keyword">open</a> <a id="1020" href="MoreAlgebra.html#3158" class="Module">MoreAlgebra.Consequences</a>
<a id="1045" class="Keyword">open</a> <a id="1050" class="Keyword">import</a> <a id="1057" href="Bundles.html" class="Module">Bundles</a>
<a id="1065" class="Comment">-- open MoreAlgebra.Properties.Group</a>

<a id="1103" class="Comment">-- https://www.cs.bham.ac.uk/~abb538/thesis.pdf</a>
<a id="1151" class="Comment">-- Booij 2020 - Analysis in Univalent Type Theory</a>

<a id="1202" class="Comment">-- Lemma 4.1.6.</a>
<a id="1218" class="Keyword">import</a> <a id="1225" href="Properties.ConstructiveField.html" class="Module">Properties.ConstructiveField</a>

<a id="1255" class="Comment">-- Lemma 4.1.11.</a>
<a id="1272" class="Keyword">import</a> <a id="1279" href="Properties.AlmostOrderedField.html" class="Module">Properties.AlmostOrderedField</a>

<a id="1310" class="Comment">-- Lemma 4.1.12. An ordered field (F, 0, 1, +, · , min, max, &lt;) is a constructive field (F, 0, 1, +, · , #).</a>
<a id="lemma-4-1-12"></a><a id="1419" href="SyntheticReals.html#1419" class="Function">lemma-4-1-12</a> <a id="1432" class="Symbol">:</a>
  <a id="1436" class="Comment">-- NOTE: we do a slightly different thing here</a>
  <a id="1485" class="Symbol">∀{</a><a id="1487" href="SyntheticReals.html#1487" class="Bound">ℓ</a> <a id="1489" href="SyntheticReals.html#1489" class="Bound">ℓ&#39;</a><a id="1491" class="Symbol">}</a> <a id="1493" class="Symbol">(</a><a id="1494" href="SyntheticReals.html#1494" class="Bound">OF</a> <a id="1497" class="Symbol">:</a> <a id="1499" href="Bundles.html#10651" class="Record">OrderedField</a> <a id="1512" class="Symbol">{</a><a id="1513" href="SyntheticReals.html#1487" class="Bound">ℓ</a><a id="1514" class="Symbol">}</a> <a id="1516" class="Symbol">{</a><a id="1517" href="SyntheticReals.html#1489" class="Bound">ℓ&#39;</a><a id="1519" class="Symbol">})</a> <a id="1522" class="Symbol">→</a>
  <a id="1526" class="Keyword">let</a> <a id="1530" class="Keyword">open</a> <a id="1535" href="Bundles.html#10651" class="Module">OrderedField</a> <a id="1548" href="SyntheticReals.html#1494" class="Bound">OF</a>
  <a id="1553" class="Comment">----------------------------------------------------</a>
  <a id="1608" class="Keyword">in</a> <a id="1611" class="Symbol">(</a><a id="1612" href="Bundles.html#4004" class="Record">IsConstructiveField</a> <a id="1632" href="Bundles.html#10758" class="Field">0f</a> <a id="1635" href="Bundles.html#10761" class="Field">1f</a> <a id="1638" href="Bundles.html#10780" class="Field Operator">_+_</a> <a id="1642" href="Bundles.html#10854" class="Field Operator">_·_</a> <a id="1646" href="Bundles.html#10822" class="Field Operator">-_</a> <a id="1649" href="Bundles.html#11012" class="Function Operator">_#_</a> <a id="1653" href="Bundles.html#11073" class="Field Operator">_⁻¹ᶠ</a><a id="1657" class="Symbol">)</a>
<a id="1659" href="SyntheticReals.html#1419" class="Function">lemma-4-1-12</a> <a id="1672" class="Symbol">{</a><a id="1673" href="SyntheticReals.html#1673" class="Bound">ℓ</a><a id="1674" class="Symbol">}</a> <a id="1676" class="Symbol">{</a><a id="1677" href="SyntheticReals.html#1677" class="Bound">ℓ&#39;</a><a id="1679" class="Symbol">}</a> <a id="1681" href="SyntheticReals.html#1681" class="Bound">OF</a> <a id="1684" class="Symbol">=</a> <a id="1686" class="Keyword">let</a> <a id="1690" class="Comment">-- NOTE: for mentioning the ℓ and ℓ&#39; and not taking them as new &quot;variables&quot; we bring them into scope</a>
  <a id="1793" class="Keyword">open</a> <a id="1798" href="Bundles.html#10651" class="Module">OrderedField</a> <a id="1811" href="SyntheticReals.html#1681" class="Bound">OF</a>
  <a id="1816" class="Keyword">in</a> <a id="1819" class="Keyword">record</a> <a id="1826" class="Comment">-- We need to show that + is #-extensional, and that # is tight.</a>
   <a id="1894" class="Symbol">{</a> <a id="1896" href="SyntheticReals.html#1896" class="Module">OrderedField</a> <a id="1909" href="SyntheticReals.html#1681" class="Bound">OF</a>
   <a id="1915" class="Symbol">;</a> <a id="1917" href="Bundles.html#4673" class="Field">isApartnessRel</a>  <a id="1933" class="Symbol">=</a> <a id="1935" href="MoreAlgebra.html#3357" class="Function">#&#39;-isApartnessRel</a> <a id="1953" href="Bundles.html#8446" class="Function">&lt;-isStrictPartialOrder</a> <a id="1976" class="Comment">-- NOTE: We&#39;ve proved this before</a>
   
     <a id="2019" class="Comment">-- First, assume w + x # y + z. We need to show w # y ∨ x # z.</a>
   <a id="2085" class="Symbol">;</a> <a id="2087" href="Bundles.html#4601" class="Field">+-#-extensional</a> <a id="2103" class="Symbol">=</a> <a id="2105" class="Symbol">λ</a> <a id="2107" class="Keyword">where</a>
                       <a id="2136" class="Comment">-- Consider the case w + x &lt; y + z, so that we can use (†) to obtain w &lt; y ∨ x &lt; z,</a>
                       <a id="2243" class="Comment">--   which gives w # y ∨ x # z in either case.</a>
                       <a id="2313" href="SyntheticReals.html#2313" class="Bound">w</a> <a id="2315" href="SyntheticReals.html#2315" class="Bound">x</a> <a id="2317" href="SyntheticReals.html#2317" class="Bound">y</a> <a id="2319" href="SyntheticReals.html#2319" class="Bound">z</a> <a id="2321" class="Symbol">(</a><a id="2322" href="Cubical.Data.Sum.Base.html#246" class="InductiveConstructor">inl</a> <a id="2326" href="SyntheticReals.html#2326" class="Bound">w+x&lt;y+z</a><a id="2333" class="Symbol">)</a> <a id="2335" class="Symbol">→</a> <a id="2337" href="Cubical.Foundations.Function.html#1093" class="Function Operator">case</a> <a id="2342" href="Bundles.html#10440" class="Function">+-&lt;-extensional</a> <a id="2358" class="Symbol">_</a> <a id="2360" class="Symbol">_</a> <a id="2362" class="Symbol">_</a> <a id="2364" class="Symbol">_</a> <a id="2366" href="SyntheticReals.html#2326" class="Bound">w+x&lt;y+z</a> <a id="2374" href="Cubical.Foundations.Function.html#1093" class="Function Operator">of</a> <a id="2377" class="Symbol">(</a>
                         <a id="2404" class="Symbol">(_</a> <a id="2407" class="Symbol">→</a> <a id="2409" class="Symbol">(</a><a id="2410" href="SyntheticReals.html#2313" class="Bound">w</a> <a id="2412" href="Bundles.html#11012" class="Function Operator">#</a> <a id="2414" href="SyntheticReals.html#2317" class="Bound">y</a><a id="2415" class="Symbol">)</a> <a id="2417" href="SyntheticReals.html#496" class="Datatype Operator">⊎</a> <a id="2419" class="Symbol">(</a><a id="2420" href="SyntheticReals.html#2315" class="Bound">x</a> <a id="2422" href="Bundles.html#11012" class="Function Operator">#</a> <a id="2424" href="SyntheticReals.html#2319" class="Bound">z</a><a id="2425" class="Symbol">))</a> <a id="2428" href="Function.Base.html#4458" class="Function Operator">∋</a> <a id="2430" class="Symbol">λ</a> <a id="2432" class="Comment">-- NOTE: here we had to add a (return-)type annotation to the λ</a>
                         <a id="2521" class="Symbol">{</a> <a id="2523" class="Symbol">(</a><a id="2524" href="Cubical.Data.Sum.Base.html#246" class="InductiveConstructor">inl</a> <a id="2528" href="SyntheticReals.html#2528" class="Bound">w&lt;y</a><a id="2531" class="Symbol">)</a> <a id="2533" class="Symbol">→</a> <a id="2535" href="Cubical.Data.Sum.Base.html#246" class="InductiveConstructor">inl</a> <a id="2539" class="Symbol">(</a><a id="2540" href="Cubical.Data.Sum.Base.html#246" class="InductiveConstructor">inl</a> <a id="2544" href="SyntheticReals.html#2528" class="Bound">w&lt;y</a><a id="2547" class="Symbol">)</a>
                         <a id="2574" class="Symbol">;</a> <a id="2576" class="Symbol">(</a><a id="2577" href="Cubical.Data.Sum.Base.html#264" class="InductiveConstructor">inr</a> <a id="2581" href="SyntheticReals.html#2581" class="Bound">x&lt;z</a><a id="2584" class="Symbol">)</a> <a id="2586" class="Symbol">→</a> <a id="2588" href="Cubical.Data.Sum.Base.html#264" class="InductiveConstructor">inr</a> <a id="2592" class="Symbol">(</a><a id="2593" href="Cubical.Data.Sum.Base.html#246" class="InductiveConstructor">inl</a> <a id="2597" href="SyntheticReals.html#2581" class="Bound">x&lt;z</a><a id="2600" class="Symbol">)</a>
                         <a id="2627" class="Symbol">})</a>
                       <a id="2653" class="Comment">-- The case w + x &gt; y + z is similar.</a>
                       <a id="2714" href="SyntheticReals.html#2714" class="Bound">w</a> <a id="2716" href="SyntheticReals.html#2716" class="Bound">x</a> <a id="2718" href="SyntheticReals.html#2718" class="Bound">y</a> <a id="2720" href="SyntheticReals.html#2720" class="Bound">z</a> <a id="2722" class="Symbol">(</a><a id="2723" href="Cubical.Data.Sum.Base.html#264" class="InductiveConstructor">inr</a> <a id="2727" href="SyntheticReals.html#2727" class="Bound">y+z&lt;w+x</a><a id="2734" class="Symbol">)</a> <a id="2736" class="Symbol">→</a> <a id="2738" href="Cubical.Foundations.Function.html#1093" class="Function Operator">case</a>  <a id="2744" href="Bundles.html#10440" class="Function">+-&lt;-extensional</a> <a id="2760" class="Symbol">_</a> <a id="2762" class="Symbol">_</a> <a id="2764" class="Symbol">_</a> <a id="2766" class="Symbol">_</a> <a id="2768" href="SyntheticReals.html#2727" class="Bound">y+z&lt;w+x</a> <a id="2776" href="Cubical.Foundations.Function.html#1093" class="Function Operator">of</a> <a id="2779" class="Symbol">(</a>
                         <a id="2806" class="Symbol">(_</a> <a id="2809" class="Symbol">→</a> <a id="2811" class="Symbol">(</a><a id="2812" href="SyntheticReals.html#2714" class="Bound">w</a> <a id="2814" href="Bundles.html#11012" class="Function Operator">#</a> <a id="2816" href="SyntheticReals.html#2718" class="Bound">y</a><a id="2817" class="Symbol">)</a> <a id="2819" href="SyntheticReals.html#496" class="Datatype Operator">⊎</a> <a id="2821" class="Symbol">(</a><a id="2822" href="SyntheticReals.html#2716" class="Bound">x</a> <a id="2824" href="Bundles.html#11012" class="Function Operator">#</a> <a id="2826" href="SyntheticReals.html#2720" class="Bound">z</a><a id="2827" class="Symbol">))</a> <a id="2830" href="Function.Base.html#4458" class="Function Operator">∋</a> <a id="2832" class="Symbol">λ</a>
                         <a id="2859" class="Symbol">{</a> <a id="2861" class="Symbol">(</a><a id="2862" href="Cubical.Data.Sum.Base.html#246" class="InductiveConstructor">inl</a> <a id="2866" href="SyntheticReals.html#2866" class="Bound">y&lt;w</a><a id="2869" class="Symbol">)</a> <a id="2871" class="Symbol">→</a> <a id="2873" href="Cubical.Data.Sum.Base.html#246" class="InductiveConstructor">inl</a> <a id="2877" class="Symbol">(</a><a id="2878" href="Cubical.Data.Sum.Base.html#264" class="InductiveConstructor">inr</a> <a id="2882" href="SyntheticReals.html#2866" class="Bound">y&lt;w</a><a id="2885" class="Symbol">)</a>
                         <a id="2912" class="Symbol">;</a> <a id="2914" class="Symbol">(</a><a id="2915" href="Cubical.Data.Sum.Base.html#264" class="InductiveConstructor">inr</a> <a id="2919" href="SyntheticReals.html#2919" class="Bound">z&lt;x</a><a id="2922" class="Symbol">)</a> <a id="2924" class="Symbol">→</a> <a id="2926" href="Cubical.Data.Sum.Base.html#264" class="InductiveConstructor">inr</a> <a id="2930" class="Symbol">(</a><a id="2931" href="Cubical.Data.Sum.Base.html#264" class="InductiveConstructor">inr</a> <a id="2935" href="SyntheticReals.html#2919" class="Bound">z&lt;x</a><a id="2938" class="Symbol">)</a>
                         <a id="2965" class="Symbol">})</a>

     <a id="2974" class="Comment">-- Tightness follows from the fact that ≤ is antisymmetric, combined with the fact</a>
     <a id="3062" class="Comment">--   that ¬(P ∨ Q) is equivalent to ¬P ∧ ¬Q.</a>
   <a id="3110" class="Symbol">;</a> <a id="3112" href="Bundles.html#4482" class="Field">#-tight</a>         <a id="3128" class="Symbol">=</a> <a id="3130" class="Symbol">λ</a> <a id="3132" href="SyntheticReals.html#3132" class="Bound">x</a> <a id="3134" href="SyntheticReals.html#3134" class="Bound">y</a> <a id="3136" href="SyntheticReals.html#3136" class="Bound">¬[x&lt;y]⊎¬[y&lt;x]</a> <a id="3150" class="Symbol">→</a> <a id="3152" class="Keyword">let</a> <a id="3156" class="Symbol">(</a><a id="3157" href="SyntheticReals.html#3157" class="Bound">¬[x&lt;y]</a> <a id="3164" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3166" href="SyntheticReals.html#3166" class="Bound">¬[y&lt;x]</a><a id="3172" class="Symbol">)</a> <a id="3174" class="Symbol">=</a> <a id="3176" href="Utils.html#891" class="Function">deMorgan₂&#39;</a> <a id="3187" href="SyntheticReals.html#3136" class="Bound">¬[x&lt;y]⊎¬[y&lt;x]</a>
                                             <a id="3246" class="Keyword">in</a>  <a id="3250" href="Bundles.html#6369" class="Function">≤-antisym</a> <a id="3260" class="Symbol">_</a> <a id="3262" class="Symbol">_</a> <a id="3264" href="SyntheticReals.html#3166" class="Bound">¬[y&lt;x]</a> <a id="3271" href="SyntheticReals.html#3157" class="Bound">¬[x&lt;y]</a>
   <a id="3281" class="Symbol">}</a>

<a id="3284" class="Comment">-- We will mainly be concerned with ordered fields, as opposed to the more general con-</a>
<a id="3372" class="Comment">-- structive fields. This is because the Archimedean property can be phrased straightforwardly</a>
<a id="3467" class="Comment">-- for ordered fields, as in Section 4.3, and because the ordering relation allows us to define loca-</a>
<a id="3569" class="Comment">-- tors, as in Chapter 6.</a>
<a id="3595" class="Comment">--</a>
<a id="3598" class="Comment">-- We have defined ordered fields, which capture the algebraic structure of the real numbers.</a>

<a id="3693" class="Comment">-- 4.2 Rationals</a>
<a id="3710" class="Comment">-- ...</a>
<a id="3717" class="Comment">-- NOTE: we have in cubical</a>
<a id="3745" class="Comment">--   import Cubical.HITs.Rationals.HITQ</a>
<a id="3785" class="Comment">--     ℚ as a higher inductive type</a>
<a id="3821" class="Comment">--   import Cubical.HITs.Rationals.QuoQ</a>
<a id="3861" class="Comment">--     ℚ as a set quotient of ℤ × ℕ₊₁ (as in the HoTT book)</a>
<a id="3921" class="Comment">--   import Cubical.HITs.Rationals.SigmaQ</a>
<a id="3963" class="Comment">--     ℚ as the set of coprime pairs in ℤ × ℕ₊₁</a>

<a id="4012" class="Keyword">import</a> <a id="4019" href="Cubical.HITs.Rationals.QuoQ.html" class="Module">Cubical.HITs.Rationals.QuoQ</a> <a id="4047" class="Keyword">renaming</a> <a id="4056" class="Symbol">(</a><a id="4057" href="Cubical.HITs.Rationals.QuoQ.Base.html#827" class="Function">ℚ</a> <a id="4059" class="Symbol">to</a> <a id="HITs.Rationals.QuoQ.Base.ℚ"></a><a id="4062" href="SyntheticReals.html#4062" class="Function">ℚ-Carrier</a><a id="4071" class="Symbol">)</a>

<a id="4074" class="Keyword">postulate</a>
  <a id="ℚℓ"></a><a id="4086" href="SyntheticReals.html#4086" class="Postulate">ℚℓ</a> <a id="4089" class="Symbol">:</a> <a id="4091" href="Agda.Primitive.html#523" class="Postulate">Level</a>
  <a id="ℚOF"></a><a id="4099" href="SyntheticReals.html#4099" class="Postulate">ℚOF</a> <a id="4103" class="Symbol">:</a> <a id="4105" href="Bundles.html#10651" class="Record">OrderedField</a> <a id="4118" class="Symbol">{</a><a id="4119" href="SyntheticReals.html#173" class="Primitive">ℓ-zero</a><a id="4125" class="Symbol">}</a> <a id="4127" class="Symbol">{</a><a id="4128" href="SyntheticReals.html#4086" class="Postulate">ℚℓ</a><a id="4130" class="Symbol">}</a>
<a id="4132" class="Comment">{-
ℚ = λ where
  .OrderedField.Carrier        → ℚ-Carrier
  .OrderedField.0f             → 0
  .OrderedField.1f             → 1
  .OrderedField._+_            → _+_
  .OrderedField.-_             → -_
  .OrderedField._·_            → _*_
  .OrderedField.min            → {!!}
  .OrderedField.max            → {!!}
  .OrderedField._&lt;_            → {!!}
  .OrderedField.&lt;-isProp       → {!!}
  .OrderedField._⁻¹ᶠ           → {!!}
  .OrderedField.isOrderedField → {!!}
-}</a>

<a id="4602" class="Comment">-- 4.3 Archimedean property</a>
<a id="4630" class="Comment">--</a>
<a id="4633" class="Comment">-- We now define the notion of Archimedean ordered fields. We phrase this in terms of a certain</a>
<a id="4729" class="Comment">-- interpolation property, that can be defined from the fact that there is a unique morphism of</a>
<a id="4825" class="Comment">-- ordered fields from the rationals to every ordered field.</a>

<a id="4887" class="Comment">-- Lemma 4.3.3. For every ordered field (F, 0 F , 1 F , + F , · F , min F , max F , &lt; F ), there is a unique morphism</a>
<a id="5005" class="Comment">-- i of ordered fields from the rationals to F . Additionally, i preserves &lt; in the sense that for every q, r : Q</a>
<a id="5119" class="Comment">--   q &lt; r ⇒ i (q) &lt; F i (r ).</a>

<a id="5151" class="Comment">-- ∃! : ∀ {ℓ ℓ&#39;} (A : Type ℓ) (B : A → Type ℓ&#39;) → Type (ℓ-max ℓ ℓ&#39;)</a>
<a id="5219" class="Comment">-- ∃! A B = isContr (Σ A B)</a>

<a id="5248" class="Comment">-- isContr&#39; A = Σ[ x ∈ A ] (∀ y → x ≡ y)</a>

<a id="ℚ-IsInitialObject"></a><a id="5290" href="SyntheticReals.html#5290" class="Function">ℚ-IsInitialObject</a> <a id="5308" class="Symbol">:</a> <a id="5310" class="Symbol">∀(</a><a id="5312" href="SyntheticReals.html#5312" class="Bound">OF</a> <a id="5315" class="Symbol">:</a> <a id="5317" href="Bundles.html#10651" class="Record">OrderedField</a> <a id="5330" class="Symbol">{</a><a id="5331" href="SyntheticReals.html#205" class="Generalizable">ℓ</a><a id="5332" class="Symbol">}</a> <a id="5334" class="Symbol">{</a><a id="5335" href="SyntheticReals.html#207" class="Generalizable">ℓ&#39;</a><a id="5337" class="Symbol">})</a> <a id="5340" class="Symbol">→</a> <a id="5342" href="Cubical.Foundations.Id.html#872" class="Function">isContr</a> <a id="5350" class="Symbol">(</a><a id="5351" href="Bundles.html#13798" class="Record">OrderedFieldMor</a> <a id="5367" href="SyntheticReals.html#4099" class="Postulate">ℚOF</a> <a id="5371" href="SyntheticReals.html#5312" class="Bound">OF</a><a id="5373" class="Symbol">)</a>
<a id="5375" href="SyntheticReals.html#5290" class="Function">ℚ-IsInitialObject</a> <a id="5393" href="SyntheticReals.html#5393" class="Bound">OF</a> <a id="5396" class="Symbol">=</a> <a id="5398" class="Symbol">{!!}</a> <a id="5403" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5405" class="Symbol">{!!}</a>

<a id="5411" class="Comment">-- Definition 4.3.5. Let (F, 0 F , 1 F , + F , · F , min F , max F , &lt; F ) be an ordered field, so that we get a</a>
<a id="5524" class="Comment">-- canonical morphism i : Q → F of ordered fields, as in Lemma 4.3.3. We say the ordered field</a>
<a id="5619" class="Comment">-- (F, 0 F , 1 F , + F , · F , min F , max F , &lt; F ) is Archimedean if</a>
<a id="5690" class="Comment">--   (∀x, y : F )(∃q : Q)x &lt; i (q) &lt; y.</a>

<a id="IsArchimedian"></a><a id="5731" href="SyntheticReals.html#5731" class="Function">IsArchimedian</a> <a id="5745" class="Symbol">:</a> <a id="5747" href="Bundles.html#10651" class="Record">OrderedField</a> <a id="5760" class="Symbol">{</a><a id="5761" href="SyntheticReals.html#205" class="Generalizable">ℓ</a><a id="5762" class="Symbol">}</a> <a id="5764" class="Symbol">{</a><a id="5765" href="SyntheticReals.html#207" class="Generalizable">ℓ&#39;</a><a id="5767" class="Symbol">}</a> <a id="5769" class="Symbol">→</a> <a id="5771" href="Agda.Primitive.html#326" class="Primitive">Type</a> <a id="5776" class="Symbol">(</a><a id="5777" href="SyntheticReals.html#142" class="Primitive">ℓ-max</a> <a id="5783" href="SyntheticReals.html#205" class="Generalizable">ℓ</a> <a id="5785" href="SyntheticReals.html#207" class="Generalizable">ℓ&#39;</a><a id="5787" class="Symbol">)</a>
<a id="5789" href="SyntheticReals.html#5731" class="Function">IsArchimedian</a> <a id="5803" href="SyntheticReals.html#5803" class="Bound">OF</a> <a id="5806" class="Symbol">=</a> <a id="5808" class="Keyword">let</a> <a id="5812" class="Symbol">(</a><a id="5813" href="Bundles.html#13949" class="InductiveConstructor">orderedfieldmor</a> <a id="5829" href="SyntheticReals.html#5829" class="Bound">i</a> <a id="5831" class="Symbol">_)</a> <a id="5834" class="Symbol">=</a> <a id="5836" href="Cubical.Foundations.Id.html#983" class="Field">fst</a> <a id="5840" class="Symbol">(</a><a id="5841" href="SyntheticReals.html#5290" class="Function">ℚ-IsInitialObject</a> <a id="5859" href="SyntheticReals.html#5803" class="Bound">OF</a><a id="5861" class="Symbol">)</a>
                       <a id="5886" class="Keyword">open</a> <a id="5891" href="Bundles.html#10651" class="Module">OrderedField</a> <a id="5904" href="SyntheticReals.html#5803" class="Bound">OF</a>
                       <a id="5930" href="SyntheticReals.html#5930" class="Bound">ℚ</a> <a id="5932" class="Symbol">=</a> <a id="5934" href="Bundles.html#10737" class="Field">OrderedField.Carrier</a> <a id="5955" href="SyntheticReals.html#4099" class="Postulate">ℚOF</a>
                   <a id="5978" class="Keyword">in</a> <a id="5981" class="Symbol">∀</a> <a id="5983" href="SyntheticReals.html#5983" class="Bound">x</a> <a id="5985" href="SyntheticReals.html#5985" class="Bound">y</a> <a id="5987" class="Symbol">→</a> <a id="5989" href="Cubical.Data.Sigma.Base.html#709" class="Function">∃[</a> <a id="5992" href="SyntheticReals.html#5992" class="Bound">q</a> <a id="5994" href="Cubical.Data.Sigma.Base.html#709" class="Function">∈</a> <a id="5996" href="SyntheticReals.html#5930" class="Bound">ℚ</a> <a id="5998" href="Cubical.Data.Sigma.Base.html#709" class="Function">]</a> <a id="6000" class="Symbol">(</a><a id="6001" href="SyntheticReals.html#5983" class="Bound">x</a> <a id="6003" href="Bundles.html#10938" class="Field Operator">&lt;</a> <a id="6005" href="SyntheticReals.html#5829" class="Bound">i</a> <a id="6007" href="SyntheticReals.html#5992" class="Bound">q</a><a id="6008" class="Symbol">)</a> <a id="6010" href="SyntheticReals.html#563" class="Function Operator">×</a> <a id="6012" class="Symbol">(</a><a id="6013" href="SyntheticReals.html#5829" class="Bound">i</a> <a id="6015" href="SyntheticReals.html#5992" class="Bound">q</a> <a id="6017" href="Bundles.html#10938" class="Field Operator">&lt;</a> <a id="6019" href="SyntheticReals.html#5985" class="Bound">y</a><a id="6020" class="Symbol">)</a>
                   
<a id="6042" class="Comment">-- If the ordered field is clear from the context, we will identify rationals q : Q with their in-</a>
<a id="6141" class="Comment">-- clusion i (q) in the ordered field, so that we may also say that (F, 0 F , 1 F , + F , · F , min F , max F , &lt; F )</a>
<a id="6259" class="Comment">-- is Archimedean if</a>
<a id="6280" class="Comment">-- (∀x, y : F )(∃q : Q)x &lt; q &lt; y.</a>

<a id="6315" class="Comment">-- Example 4.3.6. In an Archimedean ordered field, all numbers are bounded by rationals. That</a>
<a id="6409" class="Comment">-- is, for a given x : F , there exist q, r : Q with q &lt; x &lt; r .</a>

<a id="Example-4-3-6"></a><a id="6475" href="SyntheticReals.html#6475" class="Function">Example-4-3-6</a> <a id="6489" class="Symbol">:</a> <a id="6491" class="Symbol">(</a><a id="6492" href="SyntheticReals.html#6492" class="Bound">OF</a> <a id="6495" class="Symbol">:</a> <a id="6497" href="Bundles.html#10651" class="Record">OrderedField</a> <a id="6510" class="Symbol">{</a><a id="6511" href="SyntheticReals.html#205" class="Generalizable">ℓ</a><a id="6512" class="Symbol">}</a> <a id="6514" class="Symbol">{</a><a id="6515" href="SyntheticReals.html#207" class="Generalizable">ℓ&#39;</a><a id="6517" class="Symbol">})</a>
              <a id="6534" class="Symbol">→</a> <a id="6536" href="SyntheticReals.html#5731" class="Function">IsArchimedian</a> <a id="6550" href="SyntheticReals.html#6492" class="Bound">OF</a>
              <a id="6567" class="Symbol">→</a> <a id="6569" class="Keyword">let</a> <a id="6573" class="Keyword">open</a> <a id="6578" href="Bundles.html#10651" class="Module">OrderedField</a> <a id="6591" href="SyntheticReals.html#6492" class="Bound">OF</a> <a id="6594" class="Keyword">renaming</a> <a id="6603" class="Symbol">(</a><a id="6604" href="Bundles.html#10737" class="Field">Carrier</a> <a id="6612" class="Symbol">to</a> <a id="OrderedField.Carrier"></a><a id="6615" href="SyntheticReals.html#6615" class="Field">F</a><a id="6616" class="Symbol">)</a>
                    <a id="6638" class="Symbol">(</a><a id="6639" href="Bundles.html#13949" class="InductiveConstructor">orderedfieldmor</a> <a id="6655" href="SyntheticReals.html#6655" class="Bound">i</a> <a id="6657" class="Symbol">_)</a> <a id="6660" class="Symbol">=</a> <a id="6662" href="Cubical.Foundations.Id.html#983" class="Field">fst</a> <a id="6666" class="Symbol">(</a><a id="6667" href="SyntheticReals.html#5290" class="Function">ℚ-IsInitialObject</a> <a id="6685" href="SyntheticReals.html#6492" class="Bound">OF</a><a id="6687" class="Symbol">)</a>
                    <a id="6709" href="SyntheticReals.html#6709" class="Bound">ℚ</a> <a id="6711" class="Symbol">=</a> <a id="6713" href="Bundles.html#10737" class="Field">OrderedField.Carrier</a> <a id="6734" href="SyntheticReals.html#4099" class="Postulate">ℚOF</a>
                <a id="6754" class="Keyword">in</a> <a id="6757" class="Symbol">∀(</a><a id="6759" href="SyntheticReals.html#6759" class="Bound">x</a> <a id="6761" class="Symbol">:</a> <a id="6763" href="SyntheticReals.html#6615" class="Field">F</a><a id="6764" class="Symbol">)</a> <a id="6766" class="Symbol">→</a> <a id="6768" class="Symbol">(</a><a id="6769" href="Cubical.Data.Sigma.Base.html#709" class="Function">∃[</a> <a id="6772" href="SyntheticReals.html#6772" class="Bound">q</a> <a id="6774" href="Cubical.Data.Sigma.Base.html#709" class="Function">∈</a> <a id="6776" href="SyntheticReals.html#6709" class="Bound">ℚ</a> <a id="6778" href="Cubical.Data.Sigma.Base.html#709" class="Function">]</a> <a id="6780" href="SyntheticReals.html#6655" class="Bound">i</a> <a id="6782" href="SyntheticReals.html#6772" class="Bound">q</a> <a id="6784" href="Bundles.html#10938" class="Field Operator">&lt;</a> <a id="6786" href="SyntheticReals.html#6759" class="Bound">x</a><a id="6787" class="Symbol">)</a> <a id="6789" href="SyntheticReals.html#563" class="Function Operator">×</a> <a id="6791" class="Symbol">(</a><a id="6792" href="Cubical.Data.Sigma.Base.html#709" class="Function">∃[</a> <a id="6795" href="SyntheticReals.html#6795" class="Bound">r</a> <a id="6797" href="Cubical.Data.Sigma.Base.html#709" class="Function">∈</a> <a id="6799" href="SyntheticReals.html#6709" class="Bound">ℚ</a> <a id="6801" href="Cubical.Data.Sigma.Base.html#709" class="Function">]</a> <a id="6803" href="SyntheticReals.html#6759" class="Bound">x</a> <a id="6805" href="Bundles.html#10938" class="Field Operator">&lt;</a> <a id="6807" href="SyntheticReals.html#6655" class="Bound">i</a> <a id="6809" href="SyntheticReals.html#6795" class="Bound">r</a><a id="6810" class="Symbol">)</a>
<a id="6812" class="Comment">-- This follows from applying the Archimedean property to x − 1 &lt; x and x &lt; x + 1.</a>
<a id="6895" href="SyntheticReals.html#6475" class="Function">Example-4-3-6</a> <a id="6909" href="SyntheticReals.html#6909" class="Bound">OF</a> <a id="6912" href="SyntheticReals.html#6912" class="Bound">isArchimedian</a> <a id="6926" class="Symbol">=</a> <a id="6928" class="Symbol">{!!}</a>

<a id="6934" class="Comment">-- 4.4 Cauchy completeness of real numbers</a>
<a id="6977" class="Comment">--</a>
<a id="6980" class="Comment">-- We focus on Cauchy completeness, rather than Dedekind or Dedekind-MacNeille completeness,</a>
<a id="7073" class="Comment">-- as we will focus on the computation of digit expansions, for which Cauchy completeness suffices.</a>

<a id="7174" class="Comment">-- In order to state that an ordered field is Cauchy complete, we need to define when sequences</a>
<a id="7270" class="Comment">-- are Cauchy, and when a sequence has a limit. We also take the opportunity to define</a>
<a id="7357" class="Comment">-- the set of Cauchy reals in Definition 4.4.9. Surprisingly, this ordered field cannot be shown to</a>
<a id="7457" class="Comment">-- be Cauchy complete.</a>

<a id="7481" class="Comment">-- NOTE: in the following we make use of ℚ⁺ a few times. Maybe this should be a primitive?</a>

<a id="7573" class="Comment">-- Fix an ordered field (F, 0 F , 1 F , + F , · F , min F , max F , &lt; F ).</a>
<a id="7648" class="Keyword">module</a> <a id="7655" href="SyntheticReals.html#7655" class="Module">_</a> <a id="7657" class="Symbol">(</a><a id="7658" href="SyntheticReals.html#7658" class="Bound">OF</a> <a id="7661" class="Symbol">:</a> <a id="7663" href="Bundles.html#10651" class="Record">OrderedField</a> <a id="7676" class="Symbol">{</a><a id="7677" href="SyntheticReals.html#205" class="Generalizable">ℓ</a><a id="7678" class="Symbol">}</a> <a id="7680" class="Symbol">{</a><a id="7681" href="SyntheticReals.html#207" class="Generalizable">ℓ&#39;</a><a id="7683" class="Symbol">})</a> <a id="7686" class="Keyword">where</a>
  <a id="7694" class="Keyword">open</a> <a id="7699" href="Bundles.html#10651" class="Module">OrderedField</a> <a id="7712" href="SyntheticReals.html#7658" class="Bound">OF</a> <a id="7715" class="Keyword">renaming</a> <a id="7724" class="Symbol">(</a><a id="7725" href="Bundles.html#10737" class="Field">Carrier</a> <a id="7733" class="Symbol">to</a> <a id="OrderedField.Carrier"></a><a id="7736" href="SyntheticReals.html#7736" class="Field">F</a><a id="7737" class="Symbol">)</a>
  <a id="7741" class="Comment">-- module ℚ = OrderedField ℚ</a>
  <a id="7772" class="Keyword">open</a> <a id="7777" href="Bundles.html#10651" class="Module">OrderedField</a> <a id="7790" href="SyntheticReals.html#4099" class="Postulate">ℚOF</a> <a id="7794" class="Keyword">using</a> <a id="7800" class="Symbol">()</a> <a id="7803" class="Keyword">renaming</a> <a id="7812" class="Symbol">(</a><a id="7813" href="Bundles.html#10938" class="Field Operator">_&lt;_</a> <a id="7817" class="Symbol">to</a> <a id="OrderedField._&lt;_"></a><a id="7820" href="SyntheticReals.html#7820" class="Field Operator">_&lt;ᵣ_</a><a id="7824" class="Symbol">;</a> <a id="7826" href="Bundles.html#10758" class="Field">0f</a> <a id="7829" class="Symbol">to</a> <a id="OrderedField.0f"></a><a id="7832" href="SyntheticReals.html#7832" class="Field">0ᵣ</a><a id="7834" class="Symbol">)</a>
  <a id="7838" href="SyntheticReals.html#7838" class="Function">ℚ</a> <a id="7840" class="Symbol">=</a> <a id="7842" href="Bundles.html#10737" class="Field">OrderedField.Carrier</a> <a id="7863" href="SyntheticReals.html#4099" class="Postulate">ℚOF</a>
  <a id="7869" href="SyntheticReals.html#7869" class="Function">iᵣ</a> <a id="7872" class="Symbol">=</a> <a id="7874" href="Bundles.html#14033" class="Field">OrderedFieldMor.fun</a> <a id="7894" class="Symbol">(</a><a id="7895" href="Cubical.Foundations.Id.html#983" class="Field">fst</a> <a id="7899" class="Symbol">(</a><a id="7900" href="SyntheticReals.html#5290" class="Function">ℚ-IsInitialObject</a> <a id="7918" href="SyntheticReals.html#7658" class="Bound">OF</a><a id="7920" class="Symbol">))</a>
  <a id="7925" class="Keyword">open</a> <a id="7930" class="Keyword">import</a> <a id="7937" href="Data.Nat.Base.html" class="Module">Data.Nat.Base</a> <a id="7951" class="Keyword">using</a> <a id="7957" class="Symbol">(</a><a id="7958" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="7959" class="Symbol">)</a> <a id="7961" class="Keyword">renaming</a> <a id="7970" class="Symbol">(</a><a id="7971" href="Data.Nat.Base.html#1396" class="Datatype Operator">_≤_</a> <a id="7975" class="Symbol">to</a> <a id="Nat.Base._≤_"></a><a id="7978" href="SyntheticReals.html#7978" class="Datatype Operator">_≤ₙ_</a><a id="7982" class="Symbol">)</a>

  <a id="7987" class="Comment">-- We get a notion of distance, given by the absolute value as</a>
  <a id="8052" class="Comment">--   |x − y| := max F (x − y, −(x − y)).</a>

  <a id="8096" href="SyntheticReals.html#8096" class="Function">distance</a> <a id="8105" class="Symbol">:</a> <a id="8107" class="Symbol">∀(</a><a id="8109" href="SyntheticReals.html#8109" class="Bound">x</a> <a id="8111" href="SyntheticReals.html#8111" class="Bound">y</a> <a id="8113" class="Symbol">:</a> <a id="8115" href="SyntheticReals.html#7736" class="Field">F</a><a id="8116" class="Symbol">)</a> <a id="8118" class="Symbol">→</a> <a id="8120" href="SyntheticReals.html#7736" class="Field">F</a>
  <a id="8124" href="SyntheticReals.html#8096" class="Function">distance</a> <a id="8133" href="SyntheticReals.html#8133" class="Bound">x</a> <a id="8135" href="SyntheticReals.html#8135" class="Bound">y</a> <a id="8137" class="Symbol">=</a> <a id="8139" href="Bundles.html#10900" class="Field">max</a> <a id="8143" class="Symbol">(</a><a id="8144" href="SyntheticReals.html#8133" class="Bound">x</a> <a id="8146" href="Cubical.Structures.Group.Base.html#529" class="Function Operator">-</a> <a id="8148" href="SyntheticReals.html#8135" class="Bound">y</a><a id="8149" class="Symbol">)</a> <a id="8151" class="Symbol">(</a><a id="8152" href="Bundles.html#10822" class="Field Operator">-</a> <a id="8154" class="Symbol">(</a><a id="8155" href="SyntheticReals.html#8133" class="Bound">x</a> <a id="8157" href="Cubical.Structures.Group.Base.html#529" class="Function Operator">-</a> <a id="8159" href="SyntheticReals.html#8135" class="Bound">y</a><a id="8160" class="Symbol">))</a>

  <a id="8166" class="Comment">-- Consider a sequence x : N → F of elements of F . Classically, we may state that x is Cauchy as</a>
  <a id="8266" class="Comment">-- (∀ε : Q + )(∃N : N)(∀m, n : N)m, n ≥ N ⇒ |x m − x n | &lt; ε,</a>
  <a id="8330" href="SyntheticReals.html#8330" class="Function">IsCauchy</a> <a id="8339" class="Symbol">:</a> <a id="8341" class="Symbol">(</a><a id="8342" href="SyntheticReals.html#8342" class="Bound">x</a> <a id="8344" class="Symbol">:</a> <a id="8346" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="8348" class="Symbol">→</a> <a id="8350" href="SyntheticReals.html#7736" class="Field">F</a><a id="8351" class="Symbol">)</a> <a id="8353" class="Symbol">→</a> <a id="8355" href="Agda.Primitive.html#326" class="Primitive">Type</a> <a id="8360" class="Symbol">(</a><a id="8361" href="SyntheticReals.html#142" class="Primitive">ℓ-max</a> <a id="8367" href="SyntheticReals.html#7681" class="Bound">ℓ&#39;</a> <a id="8370" href="SyntheticReals.html#4086" class="Postulate">ℚℓ</a><a id="8372" class="Symbol">)</a>
  <a id="8376" href="SyntheticReals.html#8330" class="Function">IsCauchy</a> <a id="8385" href="SyntheticReals.html#8385" class="Bound">x</a> <a id="8387" class="Symbol">=</a> <a id="8389" class="Symbol">∀(</a><a id="8391" href="SyntheticReals.html#8391" class="Bound">ε</a> <a id="8393" class="Symbol">:</a> <a id="8395" href="SyntheticReals.html#7838" class="Function">ℚ</a><a id="8396" class="Symbol">)</a> <a id="8398" class="Symbol">→</a> <a id="8400" href="SyntheticReals.html#7832" class="Function">0ᵣ</a> <a id="8403" href="SyntheticReals.html#7820" class="Function Operator">&lt;ᵣ</a> <a id="8406" href="SyntheticReals.html#8391" class="Bound">ε</a> <a id="8408" class="Symbol">→</a> <a id="8410" href="Cubical.Data.Sigma.Base.html#709" class="Function">∃[</a> <a id="8413" href="SyntheticReals.html#8413" class="Bound">N</a> <a id="8415" href="Cubical.Data.Sigma.Base.html#709" class="Function">∈</a> <a id="8417" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="8419" href="Cubical.Data.Sigma.Base.html#709" class="Function">]</a> <a id="8421" class="Symbol">∀(</a><a id="8423" href="SyntheticReals.html#8423" class="Bound">m</a> <a id="8425" href="SyntheticReals.html#8425" class="Bound">n</a> <a id="8427" class="Symbol">:</a> <a id="8429" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="8430" class="Symbol">)</a> <a id="8432" class="Symbol">→</a> <a id="8434" href="SyntheticReals.html#8413" class="Bound">N</a> <a id="8436" href="SyntheticReals.html#7978" class="Datatype Operator">≤ₙ</a> <a id="8439" href="SyntheticReals.html#8423" class="Bound">m</a> <a id="8441" class="Symbol">→</a> <a id="8443" href="SyntheticReals.html#8413" class="Bound">N</a> <a id="8445" href="SyntheticReals.html#7978" class="Datatype Operator">≤ₙ</a> <a id="8448" href="SyntheticReals.html#8425" class="Bound">n</a> <a id="8450" class="Symbol">→</a> <a id="8452" href="SyntheticReals.html#8096" class="Function">distance</a> <a id="8461" class="Symbol">(</a><a id="8462" href="SyntheticReals.html#8385" class="Bound">x</a> <a id="8464" href="SyntheticReals.html#8423" class="Bound">m</a><a id="8465" class="Symbol">)</a> <a id="8467" class="Symbol">(</a><a id="8468" href="SyntheticReals.html#8385" class="Bound">x</a> <a id="8470" href="SyntheticReals.html#8425" class="Bound">n</a><a id="8471" class="Symbol">)</a> <a id="8473" href="Bundles.html#10938" class="Field Operator">&lt;</a> <a id="8475" href="SyntheticReals.html#7869" class="Function">iᵣ</a> <a id="8478" href="SyntheticReals.html#8391" class="Bound">ε</a>

  <a id="8483" class="Comment">-- We can interpret the quantifiers as in Definition 2.4.5.</a>
  <a id="8545" class="Comment">-- NOTE: this is the case, since `∃ A B = ∥ Σ A B ∥`</a>

  <a id="8601" class="Comment">-- Following a propositions-as-types interpretation, we may also state that x is Cauchy as the</a>
  <a id="8698" class="Comment">-- structure</a>
  <a id="8713" class="Comment">-- (Πε : Q + )(ΣN : N)(Πm, n : N)m, n ≥ N → |x m − x n | &lt; ε.</a>

  <a id="8778" class="Comment">-- The dependent sum represents a choice of index N for every error ε, and so we have arrived at the following definition.</a>

  <a id="8904" class="Comment">-- Definition 4.4.1.</a>
  <a id="8927" class="Comment">-- For a sequence of reals x : N → F , a a modulus of Cauchy convergence is a map M : Q + → N such that</a>
  <a id="9033" class="Comment">-- (∀ε : Q + )(∀m, n : N)m, n ≥ M (ε) ⇒ |x m − x n | &lt; ε.</a>

  <a id="9094" class="Comment">-- NOTE: do we already call these x &quot;reals&quot; ?</a>
  <a id="9142" class="Comment">-- NOTE: we are using the Modulus-type `((y : ℚ) → {{0ᵣ &lt;ᵣ y}} → ℕ)` a few times and might abbreviate it</a>
  
  <a id="9252" href="SyntheticReals.html#9252" class="Function">IsModulusOfCauchyConvergence</a> <a id="9281" class="Symbol">:</a> <a id="9283" class="Symbol">(</a><a id="9284" href="SyntheticReals.html#9284" class="Bound">x</a> <a id="9286" class="Symbol">:</a> <a id="9288" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="9290" class="Symbol">→</a> <a id="9292" href="SyntheticReals.html#7736" class="Field">F</a><a id="9293" class="Symbol">)</a> <a id="9295" class="Symbol">→</a> <a id="9297" class="Symbol">(</a><a id="9298" href="SyntheticReals.html#9298" class="Bound">M</a> <a id="9300" class="Symbol">:</a> <a id="9302" class="Symbol">((</a><a id="9304" href="SyntheticReals.html#9304" class="Bound">y</a> <a id="9306" class="Symbol">:</a> <a id="9308" href="SyntheticReals.html#7838" class="Function">ℚ</a><a id="9309" class="Symbol">)</a> <a id="9311" class="Symbol">→</a> <a id="9313" class="Symbol">{{</a><a id="9315" href="SyntheticReals.html#7832" class="Function">0ᵣ</a> <a id="9318" href="SyntheticReals.html#7820" class="Function Operator">&lt;ᵣ</a> <a id="9321" href="SyntheticReals.html#9304" class="Bound">y</a><a id="9322" class="Symbol">}}</a> <a id="9325" class="Symbol">→</a> <a id="9327" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="9328" class="Symbol">))</a> <a id="9331" class="Symbol">→</a> <a id="9333" href="Agda.Primitive.html#326" class="Primitive">Type</a> <a id="9338" class="Symbol">(</a><a id="9339" href="SyntheticReals.html#142" class="Primitive">ℓ-max</a> <a id="9345" href="SyntheticReals.html#7681" class="Bound">ℓ&#39;</a> <a id="9348" href="SyntheticReals.html#4086" class="Postulate">ℚℓ</a><a id="9350" class="Symbol">)</a>
  <a id="9354" href="SyntheticReals.html#9252" class="Function">IsModulusOfCauchyConvergence</a> <a id="9383" href="SyntheticReals.html#9383" class="Bound">x</a> <a id="9385" href="SyntheticReals.html#9385" class="Bound">M</a> <a id="9387" class="Symbol">=</a> <a id="9389" class="Symbol">∀(</a><a id="9391" href="SyntheticReals.html#9391" class="Bound">ε</a> <a id="9393" class="Symbol">:</a> <a id="9395" href="SyntheticReals.html#7838" class="Function">ℚ</a><a id="9396" class="Symbol">)</a> <a id="9398" class="Symbol">→</a> <a id="9400" class="Symbol">(</a><a id="9401" href="SyntheticReals.html#9401" class="Bound">p</a> <a id="9403" class="Symbol">:</a> <a id="9405" href="SyntheticReals.html#7832" class="Function">0ᵣ</a> <a id="9408" href="SyntheticReals.html#7820" class="Function Operator">&lt;ᵣ</a> <a id="9411" href="SyntheticReals.html#9391" class="Bound">ε</a><a id="9412" class="Symbol">)</a> <a id="9414" class="Symbol">→</a> <a id="9416" class="Symbol">∀(</a><a id="9418" href="SyntheticReals.html#9418" class="Bound">m</a> <a id="9420" href="SyntheticReals.html#9420" class="Bound">n</a> <a id="9422" class="Symbol">:</a> <a id="9424" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="9425" class="Symbol">)</a>
                                   <a id="9462" class="Symbol">→</a> <a id="9464" class="Keyword">let</a> <a id="9468" class="Keyword">instance</a> <a id="9477" href="SyntheticReals.html#9477" class="Bound">_</a> <a id="9479" class="Symbol">=</a> <a id="9481" href="SyntheticReals.html#9401" class="Bound">p</a>
                                     <a id="9520" class="Keyword">in</a> <a id="9523" href="SyntheticReals.html#9385" class="Bound">M</a> <a id="9525" href="SyntheticReals.html#9391" class="Bound">ε</a> <a id="9527" href="SyntheticReals.html#7978" class="Datatype Operator">≤ₙ</a> <a id="9530" href="SyntheticReals.html#9418" class="Bound">m</a> <a id="9532" class="Symbol">→</a> <a id="9534" href="SyntheticReals.html#9385" class="Bound">M</a> <a id="9536" href="SyntheticReals.html#9391" class="Bound">ε</a> <a id="9538" href="SyntheticReals.html#7978" class="Datatype Operator">≤ₙ</a> <a id="9541" href="SyntheticReals.html#9420" class="Bound">n</a> <a id="9543" class="Symbol">→</a> <a id="9545" href="SyntheticReals.html#8096" class="Function">distance</a> <a id="9554" class="Symbol">(</a><a id="9555" href="SyntheticReals.html#9383" class="Bound">x</a> <a id="9557" href="SyntheticReals.html#9418" class="Bound">m</a><a id="9558" class="Symbol">)</a> <a id="9560" class="Symbol">(</a><a id="9561" href="SyntheticReals.html#9383" class="Bound">x</a> <a id="9563" href="SyntheticReals.html#9420" class="Bound">n</a><a id="9564" class="Symbol">)</a> <a id="9566" href="Bundles.html#10938" class="Field Operator">&lt;</a> <a id="9568" href="SyntheticReals.html#7869" class="Function">iᵣ</a> <a id="9571" href="SyntheticReals.html#9391" class="Bound">ε</a>

  <a id="9576" class="Comment">-- In constructive mathematics, we typically use such sequences with modulus, for example,</a>
  <a id="9669" class="Comment">-- because they can sometimes be used to compute limits of Cauchy sequences, avoiding choice axioms.</a>

  <a id="9773" class="Comment">-- Definition 4.4.2.</a>
  <a id="9796" class="Comment">-- A number l : F is the limit of a sequence x : N → F if the sequence</a>
  <a id="9869" class="Comment">-- converges to l in the usual sense:</a>
  <a id="9909" class="Comment">--   (∀ε : Q + )(∃N : N)(∀n : N)n ≥ N ⇒ |x n − l | &lt; ε.</a>

  <a id="9968" href="SyntheticReals.html#9968" class="Function">IsLimit</a> <a id="9976" class="Symbol">:</a> <a id="9978" class="Symbol">(</a><a id="9979" href="SyntheticReals.html#9979" class="Bound">x</a> <a id="9981" class="Symbol">:</a> <a id="9983" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="9985" class="Symbol">→</a> <a id="9987" href="SyntheticReals.html#7736" class="Field">F</a><a id="9988" class="Symbol">)</a> <a id="9990" class="Symbol">→</a> <a id="9992" class="Symbol">(</a><a id="9993" href="SyntheticReals.html#9993" class="Bound">l</a> <a id="9995" class="Symbol">:</a> <a id="9997" href="SyntheticReals.html#7736" class="Field">F</a><a id="9998" class="Symbol">)</a> <a id="10000" class="Symbol">→</a> <a id="10002" href="Agda.Primitive.html#326" class="Primitive">Type</a> <a id="10007" class="Symbol">(</a><a id="10008" href="SyntheticReals.html#142" class="Primitive">ℓ-max</a> <a id="10014" href="SyntheticReals.html#7681" class="Bound">ℓ&#39;</a> <a id="10017" href="SyntheticReals.html#4086" class="Postulate">ℚℓ</a><a id="10019" class="Symbol">)</a>
  <a id="10023" href="SyntheticReals.html#9968" class="Function">IsLimit</a> <a id="10031" href="SyntheticReals.html#10031" class="Bound">x</a> <a id="10033" href="SyntheticReals.html#10033" class="Bound">l</a> <a id="10035" class="Symbol">=</a> <a id="10037" class="Symbol">∀(</a><a id="10039" href="SyntheticReals.html#10039" class="Bound">ε</a> <a id="10041" class="Symbol">:</a> <a id="10043" href="SyntheticReals.html#7838" class="Function">ℚ</a><a id="10044" class="Symbol">)</a> <a id="10046" class="Symbol">→</a> <a id="10048" class="Symbol">(</a><a id="10049" href="SyntheticReals.html#7832" class="Function">0ᵣ</a> <a id="10052" href="SyntheticReals.html#7820" class="Function Operator">&lt;ᵣ</a> <a id="10055" href="SyntheticReals.html#10039" class="Bound">ε</a><a id="10056" class="Symbol">)</a> <a id="10058" class="Symbol">→</a> <a id="10060" href="Cubical.Data.Sigma.Base.html#709" class="Function">∃[</a> <a id="10063" href="SyntheticReals.html#10063" class="Bound">N</a> <a id="10065" href="Cubical.Data.Sigma.Base.html#709" class="Function">∈</a> <a id="10067" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="10069" href="Cubical.Data.Sigma.Base.html#709" class="Function">]</a> <a id="10071" class="Symbol">∀(</a><a id="10073" href="SyntheticReals.html#10073" class="Bound">n</a> <a id="10075" class="Symbol">:</a> <a id="10077" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="10078" class="Symbol">)</a> <a id="10080" class="Symbol">→</a> <a id="10082" href="SyntheticReals.html#10063" class="Bound">N</a> <a id="10084" href="SyntheticReals.html#7978" class="Datatype Operator">≤ₙ</a> <a id="10087" href="SyntheticReals.html#10073" class="Bound">n</a> <a id="10089" class="Symbol">→</a> <a id="10091" href="SyntheticReals.html#8096" class="Function">distance</a> <a id="10100" class="Symbol">(</a><a id="10101" href="SyntheticReals.html#10031" class="Bound">x</a> <a id="10103" href="SyntheticReals.html#10073" class="Bound">n</a><a id="10104" class="Symbol">)</a> <a id="10106" href="SyntheticReals.html#10033" class="Bound">l</a> <a id="10108" href="Bundles.html#10938" class="Field Operator">&lt;</a> <a id="10110" href="SyntheticReals.html#7869" class="Function">iᵣ</a> <a id="10113" href="SyntheticReals.html#10039" class="Bound">ε</a>

  <a id="10118" class="Comment">-- Remark 4.4.3. We do not consider the statement of convergence in propositions-as-types</a>
  <a id="10210" class="Comment">-- </a>
  <a id="10216" class="Comment">--   (Πε : Q + )(ΣN : N)(Πn : N)n ≥ N → |x n − l | &lt; ε,</a>
  <a id="10274" class="Comment">--   </a>
  <a id="10282" class="Comment">-- because if the sequence has a modulus of Cauchy convergence M, then λε.M (ε/2) is a</a>
  <a id="10371" class="Comment">-- modulus of convergence to the limit l, so that we get an element of the above type.</a>

  <a id="10461" class="Comment">-- Definition 4.4.4.</a>
  <a id="10484" class="Comment">-- The ordered field (F, 0 F , 1 F , + F , · F , min F , max F , &lt; F ) is said to be Cauchy complete</a>
  <a id="10587" class="Comment">-- if for every sequence x with modulus of Cauchy convergence M, we have a limit of x.</a>
  <a id="10676" class="Comment">-- In other words, an ordered field is Cauchy complete iff from a sequence–modulus pair (x, M), we can compute a limit of x.</a>
  
  <a id="10806" href="SyntheticReals.html#10806" class="Function">IsCauchyComplete</a> <a id="10823" class="Symbol">:</a> <a id="10825" href="Agda.Primitive.html#326" class="Primitive">Type</a> <a id="10830" class="Symbol">(</a><a id="10831" href="SyntheticReals.html#142" class="Primitive">ℓ-max</a> <a id="10837" class="Symbol">(</a><a id="10838" href="SyntheticReals.html#142" class="Primitive">ℓ-max</a> <a id="10844" href="SyntheticReals.html#7677" class="Bound">ℓ</a> <a id="10846" href="SyntheticReals.html#7681" class="Bound">ℓ&#39;</a><a id="10848" class="Symbol">)</a> <a id="10850" href="SyntheticReals.html#4086" class="Postulate">ℚℓ</a><a id="10852" class="Symbol">)</a>
  <a id="10856" href="SyntheticReals.html#10806" class="Function">IsCauchyComplete</a> <a id="10873" class="Symbol">=</a> <a id="10875" class="Symbol">(</a><a id="10876" href="SyntheticReals.html#10876" class="Bound">x</a> <a id="10878" class="Symbol">:</a> <a id="10880" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="10882" class="Symbol">→</a> <a id="10884" href="SyntheticReals.html#7736" class="Field">F</a><a id="10885" class="Symbol">)</a>
                   <a id="10906" class="Symbol">→</a> <a id="10908" class="Symbol">(</a><a id="10909" href="SyntheticReals.html#10909" class="Bound">M</a> <a id="10911" class="Symbol">:</a> <a id="10913" class="Symbol">((</a><a id="10915" href="SyntheticReals.html#10915" class="Bound">y</a> <a id="10917" class="Symbol">:</a> <a id="10919" href="SyntheticReals.html#7838" class="Function">ℚ</a><a id="10920" class="Symbol">)</a> <a id="10922" class="Symbol">→</a> <a id="10924" class="Symbol">{{</a><a id="10926" href="SyntheticReals.html#7832" class="Function">0ᵣ</a> <a id="10929" href="SyntheticReals.html#7820" class="Function Operator">&lt;ᵣ</a> <a id="10932" href="SyntheticReals.html#10915" class="Bound">y</a><a id="10933" class="Symbol">}}</a> <a id="10936" class="Symbol">→</a> <a id="10938" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="10939" class="Symbol">))</a>
                   <a id="10961" class="Symbol">→</a> <a id="10963" href="SyntheticReals.html#9252" class="Function">IsModulusOfCauchyConvergence</a> <a id="10992" href="SyntheticReals.html#10876" class="Bound">x</a> <a id="10994" href="SyntheticReals.html#10909" class="Bound">M</a>
                   <a id="11015" class="Symbol">→</a> <a id="11017" href="Cubical.Core.Primitives.html#6306" class="Function">Σ[</a> <a id="11020" href="SyntheticReals.html#11020" class="Bound">l</a> <a id="11022" href="Cubical.Core.Primitives.html#6306" class="Function">∈</a> <a id="11024" href="SyntheticReals.html#7736" class="Field">F</a> <a id="11026" href="Cubical.Core.Primitives.html#6306" class="Function">]</a> <a id="11028" href="SyntheticReals.html#9968" class="Function">IsLimit</a> <a id="11036" href="SyntheticReals.html#10876" class="Bound">x</a> <a id="11038" href="SyntheticReals.html#11020" class="Bound">l</a>

  <a id="11043" class="Comment">-- For the remainder of this section, additionally assume that F is Archimedean.</a>
  <a id="11126" class="Keyword">module</a> <a id="11133" href="SyntheticReals.html#11133" class="Module">_</a> <a id="11135" class="Symbol">(</a><a id="11136" href="SyntheticReals.html#11136" class="Bound">isArchimedian</a> <a id="11150" class="Symbol">:</a> <a id="11152" href="SyntheticReals.html#5731" class="Function">IsArchimedian</a> <a id="11166" href="SyntheticReals.html#7658" class="Bound">OF</a><a id="11168" class="Symbol">)</a> <a id="11170" class="Keyword">where</a>

    <a id="11181" class="Comment">-- Lemma 4.4.5.</a>
    <a id="11201" class="Comment">-- The type of limits of a fixed sequence x : N → F is a proposition.</a>
    <a id="11275" href="SyntheticReals.html#11275" class="Function">Lemma-4-4-5</a> <a id="11287" class="Symbol">:</a> <a id="11289" class="Symbol">∀(</a><a id="11291" href="SyntheticReals.html#11291" class="Bound">x</a> <a id="11293" class="Symbol">:</a> <a id="11295" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="11297" class="Symbol">→</a> <a id="11299" href="SyntheticReals.html#7736" class="Field">F</a><a id="11300" class="Symbol">)</a> <a id="11302" class="Symbol">→</a> <a id="11304" href="Cubical.Foundations.Id.html#910" class="Function">isProp</a> <a id="11311" class="Symbol">(</a><a id="11312" href="Cubical.Core.Primitives.html#6306" class="Function">Σ[</a> <a id="11315" href="SyntheticReals.html#11315" class="Bound">l</a> <a id="11317" href="Cubical.Core.Primitives.html#6306" class="Function">∈</a> <a id="11319" href="SyntheticReals.html#7736" class="Field">F</a> <a id="11321" href="Cubical.Core.Primitives.html#6306" class="Function">]</a> <a id="11323" href="SyntheticReals.html#9968" class="Function">IsLimit</a> <a id="11331" href="SyntheticReals.html#11291" class="Bound">x</a> <a id="11333" href="SyntheticReals.html#11315" class="Bound">l</a><a id="11334" class="Symbol">)</a>
    <a id="11340" class="Comment">-- Proof. This can be shown using the usual proof that limits are unique in Archimedean ordered fields, followed by an application of Lemma 2.6.20.</a>
    <a id="11492" href="SyntheticReals.html#11275" class="Function">Lemma-4-4-5</a> <a id="11504" href="SyntheticReals.html#11504" class="Bound">x</a> <a id="11506" class="Symbol">=</a> <a id="11508" class="Symbol">{!!}</a>

    <a id="11518" class="Comment">-- Corollary 4.4.6.</a>
    <a id="11542" class="Comment">-- Fix a given sequence x : N → F . Suppose that we know that there exists a</a>
    <a id="11623" class="Comment">-- limit of the sequence. Then we can compute a limit of the sequence.</a>
    <a id="11698" href="SyntheticReals.html#11698" class="Function">Corollary-4-4-6</a> <a id="11714" class="Symbol">:</a> <a id="11716" class="Symbol">∀(</a><a id="11718" href="SyntheticReals.html#11718" class="Bound">x</a> <a id="11720" class="Symbol">:</a> <a id="11722" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="11724" class="Symbol">→</a> <a id="11726" href="SyntheticReals.html#7736" class="Field">F</a><a id="11727" class="Symbol">)</a> <a id="11729" class="Symbol">→</a> <a id="11731" class="Symbol">(</a><a id="11732" href="Cubical.Data.Sigma.Base.html#709" class="Function">∃[</a> <a id="11735" href="SyntheticReals.html#11735" class="Bound">l</a> <a id="11737" href="Cubical.Data.Sigma.Base.html#709" class="Function">∈</a> <a id="11739" href="SyntheticReals.html#7736" class="Field">F</a> <a id="11741" href="Cubical.Data.Sigma.Base.html#709" class="Function">]</a> <a id="11743" href="SyntheticReals.html#9968" class="Function">IsLimit</a> <a id="11751" href="SyntheticReals.html#11718" class="Bound">x</a> <a id="11753" href="SyntheticReals.html#11735" class="Bound">l</a><a id="11754" class="Symbol">)</a> <a id="11756" class="Symbol">→</a> <a id="11758" href="Cubical.Core.Primitives.html#6306" class="Function">Σ[</a> <a id="11761" href="SyntheticReals.html#11761" class="Bound">l</a> <a id="11763" href="Cubical.Core.Primitives.html#6306" class="Function">∈</a> <a id="11765" href="SyntheticReals.html#7736" class="Field">F</a> <a id="11767" href="Cubical.Core.Primitives.html#6306" class="Function">]</a> <a id="11769" href="SyntheticReals.html#9968" class="Function">IsLimit</a> <a id="11777" href="SyntheticReals.html#11718" class="Bound">x</a> <a id="11779" href="SyntheticReals.html#11761" class="Bound">l</a>
    <a id="11785" class="Comment">-- Proof. By applying the induction principle of propositional truncations of Definition 2.4.3.</a>
    <a id="11885" href="SyntheticReals.html#11698" class="Function">Corollary-4-4-6</a> <a id="11901" href="SyntheticReals.html#11901" class="Bound">x</a> <a id="11903" href="SyntheticReals.html#11903" class="Bound">p</a> <a id="11905" class="Symbol">=</a> <a id="11907" class="Symbol">{!!}</a> <a id="11912" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="11914" class="Symbol">{!!}</a>

    <a id="11924" class="Comment">-- Corollary 4.4.7.</a>
    <a id="11948" class="Comment">-- Fix a given sequence x : N → F . Suppose that, from a modulus of Cauchy</a>
    <a id="12027" class="Comment">-- convergence, we can compute a limit of the sequence. Then from the existence of the modulus of</a>
    <a id="12129" class="Comment">-- Cauchy convergence we can compute a limit of the sequence.</a>
    <a id="12195" href="SyntheticReals.html#12195" class="Function">Corollary-4-4-7</a> <a id="12211" class="Symbol">:</a> <a id="12213" class="Symbol">(</a><a id="12214" href="SyntheticReals.html#12214" class="Bound">x</a> <a id="12216" class="Symbol">:</a> <a id="12218" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="12220" class="Symbol">→</a> <a id="12222" href="SyntheticReals.html#7736" class="Field">F</a><a id="12223" class="Symbol">)</a>
                    <a id="12245" class="Symbol">→</a> <a id="12247" class="Symbol">(</a> <a id="12249" class="Symbol">(</a><a id="12250" href="SyntheticReals.html#12250" class="Bound">M</a> <a id="12252" class="Symbol">:</a> <a id="12254" class="Symbol">((</a><a id="12256" href="SyntheticReals.html#12256" class="Bound">y</a> <a id="12258" class="Symbol">:</a> <a id="12260" href="SyntheticReals.html#7838" class="Function">ℚ</a><a id="12261" class="Symbol">)</a> <a id="12263" class="Symbol">→</a> <a id="12265" class="Symbol">{{</a><a id="12267" href="SyntheticReals.html#7832" class="Function">0ᵣ</a> <a id="12270" href="SyntheticReals.html#7820" class="Function Operator">&lt;ᵣ</a> <a id="12273" href="SyntheticReals.html#12256" class="Bound">y</a><a id="12274" class="Symbol">}}</a> <a id="12277" class="Symbol">→</a> <a id="12279" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="12280" class="Symbol">))</a>
                      <a id="12305" class="Symbol">→</a> <a id="12307" class="Symbol">(</a><a id="12308" href="SyntheticReals.html#12308" class="Bound">isMCC</a> <a id="12314" class="Symbol">:</a> <a id="12316" href="SyntheticReals.html#9252" class="Function">IsModulusOfCauchyConvergence</a> <a id="12345" href="SyntheticReals.html#12214" class="Bound">x</a> <a id="12347" href="SyntheticReals.html#12250" class="Bound">M</a><a id="12348" class="Symbol">)</a>
                      <a id="12372" class="Symbol">→</a> <a id="12374" href="Cubical.Core.Primitives.html#6306" class="Function">Σ[</a> <a id="12377" href="SyntheticReals.html#12377" class="Bound">l</a> <a id="12379" href="Cubical.Core.Primitives.html#6306" class="Function">∈</a> <a id="12381" href="SyntheticReals.html#7736" class="Field">F</a> <a id="12383" href="Cubical.Core.Primitives.html#6306" class="Function">]</a> <a id="12385" href="SyntheticReals.html#9968" class="Function">IsLimit</a> <a id="12393" href="SyntheticReals.html#12214" class="Bound">x</a> <a id="12395" href="SyntheticReals.html#12377" class="Bound">l</a>
                      <a id="12419" class="Symbol">)</a>
                    <a id="12441" class="Comment">-----------------------------------------------------------------------</a>
                    <a id="12533" class="Symbol">→</a> <a id="12535" href="Cubical.Data.Sigma.Base.html#709" class="Function">∃[</a> <a id="12538" href="SyntheticReals.html#12538" class="Bound">M</a> <a id="12540" href="Cubical.Data.Sigma.Base.html#709" class="Function">∈</a> <a id="12542" class="Symbol">((</a><a id="12544" href="SyntheticReals.html#12544" class="Bound">y</a> <a id="12546" class="Symbol">:</a> <a id="12548" href="SyntheticReals.html#7838" class="Function">ℚ</a><a id="12549" class="Symbol">)</a> <a id="12551" class="Symbol">→</a> <a id="12553" class="Symbol">{{</a><a id="12555" href="SyntheticReals.html#7832" class="Function">0ᵣ</a> <a id="12558" href="SyntheticReals.html#7820" class="Function Operator">&lt;ᵣ</a> <a id="12561" href="SyntheticReals.html#12544" class="Bound">y</a><a id="12562" class="Symbol">}}</a> <a id="12565" class="Symbol">→</a> <a id="12567" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="12568" class="Symbol">)</a> <a id="12570" href="Cubical.Data.Sigma.Base.html#709" class="Function">]</a> <a id="12572" href="SyntheticReals.html#9252" class="Function">IsModulusOfCauchyConvergence</a> <a id="12601" href="SyntheticReals.html#12214" class="Bound">x</a> <a id="12603" href="SyntheticReals.html#12538" class="Bound">M</a>
                    <a id="12625" class="Symbol">→</a> <a id="12627" href="Cubical.Core.Primitives.html#6306" class="Function">Σ[</a> <a id="12630" href="SyntheticReals.html#12630" class="Bound">l</a> <a id="12632" href="Cubical.Core.Primitives.html#6306" class="Function">∈</a> <a id="12634" href="SyntheticReals.html#7736" class="Field">F</a> <a id="12636" href="Cubical.Core.Primitives.html#6306" class="Function">]</a> <a id="12638" href="SyntheticReals.html#9968" class="Function">IsLimit</a> <a id="12646" href="SyntheticReals.html#12214" class="Bound">x</a> <a id="12648" href="SyntheticReals.html#12630" class="Bound">l</a>
    <a id="12654" class="Comment">-- Proof. By applying the induction principle of propositional truncations of Definition 2.4.3.</a>
    <a id="12754" href="SyntheticReals.html#12195" class="Function">Corollary-4-4-7</a> <a id="12770" href="SyntheticReals.html#12770" class="Bound">x</a> <a id="12772" href="SyntheticReals.html#12772" class="Bound">f</a> <a id="12774" href="SyntheticReals.html#12774" class="Bound">p</a> <a id="12776" class="Symbol">=</a> <a id="12778" class="Symbol">{!!}</a>

    <a id="12788" class="Comment">-- We can thus compute the limit of x : N → F as the number lim(x, p), where p is a proof</a>
    <a id="12882" class="Comment">-- that the limit of x exists. We will rather use the more traditional notation lim n→∞ x n for this</a>
    <a id="12987" class="Comment">-- number.</a>

    <a id="13003" class="Comment">-- Example 4.4.8 (Exponential function).</a>
    <a id="13048" class="Comment">-- In a Cauchy complete Archimedean ordered field, we can define an exponential function exp : F → F by</a>
    <a id="13156" class="Comment">--</a>
    <a id="13163" class="Comment">--    exp(x) = Σ_{k=0}^{∞} (xᵏ) / (k!)</a>
    <a id="13206" class="Comment">--</a>
    <a id="13213" class="Comment">-- For a given input x, we obtain the existence of a modulus of Cauchy convergence for the output from boundedness of</a>
    <a id="13335" class="Comment">-- x, that is, from the fact that (∃q, r : Q) q &lt; x &lt; r .</a>

    <a id="13398" href="SyntheticReals.html#13398" class="Function">exp</a> <a id="13402" class="Symbol">:</a> <a id="13404" href="SyntheticReals.html#7736" class="Field">F</a> <a id="13406" class="Symbol">→</a> <a id="13408" href="SyntheticReals.html#7736" class="Field">F</a>
    <a id="13414" href="SyntheticReals.html#13398" class="Function">exp</a> <a id="13418" href="SyntheticReals.html#13418" class="Bound">x</a> <a id="13420" class="Symbol">=</a> <a id="13422" class="Symbol">{!!}</a>

    <a id="13432" href="SyntheticReals.html#13432" class="Function">Example-4-4-8</a> <a id="13446" class="Symbol">:</a> <a id="13448" class="Symbol">∀(</a><a id="13450" href="SyntheticReals.html#13450" class="Bound">x</a> <a id="13452" class="Symbol">:</a> <a id="13454" href="SyntheticReals.html#7736" class="Field">F</a><a id="13455" class="Symbol">)</a> <a id="13457" class="Symbol">→</a> <a id="13459" href="Cubical.Data.Sigma.Base.html#709" class="Function">∃[</a> <a id="13462" href="SyntheticReals.html#13462" class="Bound">M</a> <a id="13464" href="Cubical.Data.Sigma.Base.html#709" class="Function">∈</a> <a id="13466" class="Symbol">((</a><a id="13468" href="SyntheticReals.html#13468" class="Bound">y</a> <a id="13470" class="Symbol">:</a> <a id="13472" href="SyntheticReals.html#7838" class="Function">ℚ</a><a id="13473" class="Symbol">)</a> <a id="13475" class="Symbol">→</a> <a id="13477" class="Symbol">{{</a><a id="13479" href="SyntheticReals.html#7832" class="Function">0ᵣ</a> <a id="13482" href="SyntheticReals.html#7820" class="Function Operator">&lt;ᵣ</a> <a id="13485" href="SyntheticReals.html#13468" class="Bound">y</a><a id="13486" class="Symbol">}}</a> <a id="13489" class="Symbol">→</a> <a id="13491" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="13492" class="Symbol">)</a> <a id="13494" href="Cubical.Data.Sigma.Base.html#709" class="Function">]</a> <a id="13496" href="SyntheticReals.html#9252" class="Function">IsModulusOfCauchyConvergence</a> <a id="13525" class="Symbol">{!!}</a> <a id="13530" href="SyntheticReals.html#13462" class="Bound">M</a>
    <a id="13536" href="SyntheticReals.html#13432" class="Function">Example-4-4-8</a> <a id="13550" href="SyntheticReals.html#13550" class="Bound">x</a> <a id="13552" class="Keyword">with</a> <a id="13557" href="SyntheticReals.html#6475" class="Function">Example-4-3-6</a> <a id="13571" href="SyntheticReals.html#7658" class="Bound">OF</a> <a id="13574" href="SyntheticReals.html#11136" class="Bound">isArchimedian</a> <a id="13588" href="SyntheticReals.html#13550" class="Bound">x</a>
    <a id="13594" class="Symbol">...</a> <a id="13598" class="Symbol">|</a> <a id="13600" href="SyntheticReals.html#13600" class="Bound">q&#39;</a> <a id="13603" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="13605" href="SyntheticReals.html#13605" class="Bound">r&#39;</a> <a id="13608" class="Symbol">=</a> <a id="13610" class="Keyword">let</a> <a id="13614" href="SyntheticReals.html#13614" class="Bound">q</a> <a id="13616" class="Symbol">:</a> <a id="13618" href="Cubical.Data.Sigma.Base.html#709" class="Function">∃[</a> <a id="13621" href="SyntheticReals.html#13621" class="Bound">q</a> <a id="13623" href="Cubical.Data.Sigma.Base.html#709" class="Function">∈</a> <a id="13625" href="SyntheticReals.html#7838" class="Function">ℚ</a> <a id="13627" href="Cubical.Data.Sigma.Base.html#709" class="Function">]</a> <a id="13629" href="SyntheticReals.html#7869" class="Function">iᵣ</a> <a id="13632" href="SyntheticReals.html#13621" class="Bound">q</a> <a id="13634" href="Bundles.html#10938" class="Field Operator">&lt;</a> <a id="13636" class="Bound">x</a>
                        <a id="13662" href="SyntheticReals.html#13614" class="Bound">q</a> <a id="13664" class="Symbol">=</a> <a id="13666" href="SyntheticReals.html#13600" class="Bound">q&#39;</a>
                        <a id="13693" href="SyntheticReals.html#13693" class="Bound">r</a> <a id="13695" class="Symbol">:</a> <a id="13697" href="Cubical.Data.Sigma.Base.html#709" class="Function">∃[</a> <a id="13700" href="SyntheticReals.html#13700" class="Bound">r</a> <a id="13702" href="Cubical.Data.Sigma.Base.html#709" class="Function">∈</a> <a id="13704" href="SyntheticReals.html#7838" class="Function">ℚ</a> <a id="13706" href="Cubical.Data.Sigma.Base.html#709" class="Function">]</a> <a id="13708" class="Bound">x</a> <a id="13710" href="Bundles.html#10938" class="Field Operator">&lt;</a> <a id="13712" href="SyntheticReals.html#7869" class="Function">iᵣ</a> <a id="13715" href="SyntheticReals.html#13700" class="Bound">r</a>
                        <a id="13741" href="SyntheticReals.html#13693" class="Bound">r</a> <a id="13743" class="Symbol">=</a> <a id="13745" href="SyntheticReals.html#13605" class="Bound">r&#39;</a>
                    <a id="13768" class="Keyword">in</a> <a id="13771" class="Symbol">{!!}</a>

    <a id="13781" class="Comment">-- The point of this work is that, because we have a single language for properties and struc-</a>
    <a id="13880" class="Comment">-- ture, we can see more precisely what is needed for certain computations. In the above example,</a>
    <a id="13982" class="Comment">-- we explicitly do not require that inputs come equipped with a modulus of Cauchy convergence,</a>
    <a id="14082" class="Comment">-- but rather that there exists such a modulus. On the one hand, we do need a modulus to obtain</a>
    <a id="14182" class="Comment">-- the limit, but as the limit value is independent of the chosen modulus, existence of such a</a>
    <a id="14281" class="Comment">-- modulus suffices.</a>

    <a id="14307" class="Comment">-- Definition 4.4.9. The Cauchy reals ℝC is the collection of rational sequences equipped with</a>
    <a id="14406" class="Comment">-- a modulus of Cauchy convergence, quotiented (as in Section 2.7) by an equivalence relation</a>
    <a id="14504" class="Comment">-- that relates two sequence–modulus pairs (x, M) and (y, N ) iff</a>
    <a id="14574" class="Comment">-- (∀ε : Q + ) x M (ε/4) − y M (ε/4) &lt; ε.</a>

    <a id="14621" href="SyntheticReals.html#14621" class="Function">ℝC</a> <a id="14624" class="Symbol">:</a> <a id="14626" class="UnsolvedMeta Symbol">{!!}</a>
    <a id="14635" href="SyntheticReals.html#14621" class="Function">ℝC</a> <a id="14638" class="Symbol">=</a> <a id="14640" class="Symbol">{!!}</a>

    <a id="14650" class="Comment">-- The Cauchy reals form an Archimedean ordered field in a natural way. The natural strategy</a>
    <a id="14747" class="Comment">-- to prove that the Cauchy reals are Cauchy complete, perhaps surprisingly, does not work, and</a>
    <a id="14847" class="Comment">-- in some constructive foundations the Cauchy completeness of the Cauchy reals is known to</a>
    <a id="14943" class="Comment">-- be false [68].</a>
    <a id="14965" class="Comment">-- </a>
    <a id="14973" class="Comment">-- ...</a>
    <a id="14984" class="Comment">-- </a>
    <a id="14992" class="Comment">-- An alternative interpretation of the non-completeness of the Cauchy reals is that the sequential</a>
    <a id="15096" class="Comment">-- definition of completeness ought to be amended [80].</a>
    
    <a id="15161" class="Comment">-- NOTE: now we&#39;re back to https://github.com/agda/cubical/issues/286 ?</a>
</pre></body></html>