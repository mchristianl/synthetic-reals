<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>SyntheticReals</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Symbol">{-#</a> <a id="5" class="Keyword">OPTIONS</a> <a id="13" class="Pragma">--cubical</a> <a id="23" class="Pragma">--no-import-sorts</a> <a id="41" class="Pragma">--allow-unsolved-metas</a> <a id="64" class="Symbol">#-}</a>

<a id="69" class="Keyword">module</a> <a id="76" href="SyntheticReals.html" class="Module">SyntheticReals</a> <a id="91" class="Keyword">where</a>

<a id="98" class="Keyword">open</a> <a id="103" class="Keyword">import</a> <a id="110" href="Agda.Primitive.html" class="Module">Agda.Primitive</a> <a id="125" class="Keyword">renaming</a> <a id="134" class="Symbol">(</a><a id="135" href="Agda.Primitive.html#736" class="Primitive Operator">_⊔_</a> <a id="139" class="Symbol">to</a> <a id="Primitive._⊔_"></a><a id="142" href="SyntheticReals.html#142" class="Primitive Operator">ℓ-max</a><a id="147" class="Symbol">;</a> <a id="149" href="Agda.Primitive.html#706" class="Primitive">lsuc</a> <a id="154" class="Symbol">to</a> <a id="Primitive.lsuc"></a><a id="157" href="SyntheticReals.html#157" class="Primitive">ℓ-suc</a><a id="162" class="Symbol">;</a> <a id="164" href="Agda.Primitive.html#690" class="Primitive">lzero</a> <a id="170" class="Symbol">to</a> <a id="Primitive.lzero"></a><a id="173" href="SyntheticReals.html#173" class="Primitive">ℓ-zero</a><a id="179" class="Symbol">)</a>

<a id="182" class="Keyword">private</a>
  <a id="192" class="Keyword">variable</a>
    <a id="205" href="SyntheticReals.html#205" class="Generalizable">ℓ</a> <a id="207" href="SyntheticReals.html#207" class="Generalizable">ℓ&#39;</a> <a id="210" href="SyntheticReals.html#210" class="Generalizable">ℓ&#39;&#39;</a> <a id="214" class="Symbol">:</a> <a id="216" href="Agda.Primitive.html#523" class="Postulate">Level</a>

<a id="223" class="Keyword">open</a> <a id="228" class="Keyword">import</a> <a id="235" href="Cubical.Foundations.Everything.html" class="Module">Cubical.Foundations.Everything</a> <a id="266" class="Keyword">renaming</a> <a id="275" class="Symbol">(</a><a id="276" href="Cubical.Foundations.GroupoidLaws.html#311" class="Function Operator">_⁻¹</a> <a id="280" class="Symbol">to</a> <a id="Foundations.GroupoidLaws._⁻¹"></a><a id="283" href="SyntheticReals.html#283" class="Function Operator">_⁻¹ᵖ</a><a id="287" class="Symbol">;</a> <a id="289" href="Cubical.Foundations.GroupoidLaws.html#2243" class="Function">assoc</a> <a id="295" class="Symbol">to</a> <a id="Foundations.GroupoidLaws.assoc"></a><a id="298" href="SyntheticReals.html#298" class="Function">∙-assoc</a><a id="305" class="Symbol">)</a>
<a id="307" class="Keyword">open</a> <a id="312" class="Keyword">import</a> <a id="319" href="Cubical.Structures.CommRing.html" class="Module">Cubical.Structures.CommRing</a>
<a id="347" class="Keyword">open</a> <a id="352" class="Keyword">import</a> <a id="359" href="Cubical.Relation.Nullary.Base.html" class="Module">Cubical.Relation.Nullary.Base</a> <a id="389" class="Comment">-- ¬_</a>
<a id="395" class="Keyword">open</a> <a id="400" class="Keyword">import</a> <a id="407" href="Cubical.Relation.Binary.Base.html" class="Module">Cubical.Relation.Binary.Base</a> <a id="436" class="Comment">-- Rel</a>
<a id="443" class="Keyword">open</a> <a id="448" class="Keyword">import</a> <a id="455" href="Cubical.Data.Sum.Base.html" class="Module">Cubical.Data.Sum.Base</a> <a id="477" class="Keyword">renaming</a> <a id="486" class="Symbol">(</a><a id="487" href="Cubical.Data.Sum.Base.html#188" class="Datatype Operator">_⊎_</a> <a id="491" class="Symbol">to</a> <a id="494" class="Keyword">infixr</a> <a id="501" class="Number">4</a> <a id="Data.Sum.Base._⊎_"></a><a id="503" href="SyntheticReals.html#503" class="Datatype Operator">_⊎_</a><a id="506" class="Symbol">)</a>
<a id="508" class="Keyword">open</a> <a id="513" class="Keyword">import</a> <a id="520" href="Cubical.Data.Sigma.Base.html" class="Module">Cubical.Data.Sigma.Base</a> <a id="544" class="Keyword">renaming</a> <a id="553" class="Symbol">(</a><a id="554" href="Cubical.Data.Sigma.Base.html#489" class="Function Operator">_×_</a> <a id="558" class="Symbol">to</a> <a id="561" class="Keyword">infixr</a> <a id="568" class="Number">4</a> <a id="Data.Sigma.Base._×_"></a><a id="570" href="SyntheticReals.html#570" class="Function Operator">_×_</a><a id="573" class="Symbol">)</a>
<a id="575" class="Keyword">open</a> <a id="580" class="Keyword">import</a> <a id="587" href="Cubical.Data.Empty.html" class="Module">Cubical.Data.Empty</a> <a id="606" class="Keyword">renaming</a> <a id="615" class="Symbol">(</a><a id="616" href="Cubical.Data.Empty.Base.html#190" class="Function">elim</a> <a id="621" class="Symbol">to</a> <a id="Data.Empty.Base.elim"></a><a id="624" href="SyntheticReals.html#624" class="Function">⊥-elim</a><a id="630" class="Symbol">)</a> <a id="632" class="Comment">-- `⊥` and `elim`</a>
<a id="650" class="Comment">-- open import Cubical.Structures.Poset</a>
<a id="690" class="Keyword">open</a> <a id="695" class="Keyword">import</a> <a id="702" href="Cubical.Foundations.Function.html" class="Module">Cubical.Foundations.Function</a>

<a id="732" class="Keyword">open</a> <a id="737" class="Keyword">import</a> <a id="744" href="Function.Base.html" class="Module">Function.Base</a> <a id="758" class="Keyword">using</a> <a id="764" class="Symbol">(</a><a id="765" href="Function.Base.html#4458" class="Function Operator">_∋_</a><a id="768" class="Symbol">)</a>
<a id="770" class="Comment">-- open import Function.Reasoning using (∋-syntax)</a>
<a id="821" class="Keyword">open</a> <a id="826" class="Keyword">import</a> <a id="833" href="Function.Base.html" class="Module">Function.Base</a> <a id="847" class="Keyword">using</a> <a id="853" class="Symbol">(</a><a id="854" href="Function.Base.html#4708" class="Function">it</a><a id="856" class="Symbol">)</a> <a id="858" class="Comment">-- instance search</a>

<a id="878" class="Keyword">open</a> <a id="883" class="Keyword">import</a> <a id="890" href="Utils.html" class="Module">Utils</a>
<a id="896" class="Keyword">open</a> <a id="901" class="Keyword">import</a> <a id="908" href="MoreLogic.html" class="Module">MoreLogic</a>
<a id="918" class="Keyword">open</a> <a id="923" href="MoreLogic.html#720" class="Module">MoreLogic.Reasoning</a>
<a id="943" class="Keyword">open</a> <a id="948" href="MoreLogic.html#1499" class="Module">MoreLogic.Properties</a>
<a id="969" class="Keyword">open</a> <a id="974" class="Keyword">import</a> <a id="981" href="MoreAlgebra.html" class="Module">MoreAlgebra</a>
<a id="993" class="Keyword">open</a> <a id="998" href="MoreAlgebra.html#605" class="Module">MoreAlgebra.Definitions</a>
<a id="1022" class="Keyword">open</a> <a id="1027" href="MoreAlgebra.html#3472" class="Module">MoreAlgebra.Consequences</a>
<a id="1052" class="Keyword">open</a> <a id="1057" class="Keyword">import</a> <a id="1064" href="Bundles.html" class="Module">Bundles</a>
<a id="1072" class="Comment">-- open MoreAlgebra.Properties.Group</a>

<a id="1110" class="Comment">-- https://www.cs.bham.ac.uk/~abb538/thesis.pdf</a>
<a id="1158" class="Comment">-- Booij 2020 - Analysis in Univalent Type Theory</a>

<a id="1209" class="Comment">-- Lemma 4.1.6.</a>
<a id="1225" class="Keyword">import</a> <a id="1232" href="Properties.ConstructiveField.html" class="Module">Properties.ConstructiveField</a>

<a id="1262" class="Comment">-- Lemma 4.1.11.</a>
<a id="1279" class="Keyword">import</a> <a id="1286" href="Properties.AlmostOrderedField.html" class="Module">Properties.AlmostOrderedField</a>

<a id="1317" class="Comment">-- Lemma 4.1.12. An ordered field (F, 0, 1, +, · , min, max, &lt;) is a constructive field (F, 0, 1, +, · , #).</a>
<a id="lemma-4-1-12"></a><a id="1426" href="SyntheticReals.html#1426" class="Function">lemma-4-1-12</a> <a id="1439" class="Symbol">:</a>
  <a id="1443" class="Comment">-- NOTE: we do a slightly different thing here</a>
  <a id="1492" class="Symbol">∀{</a><a id="1494" href="SyntheticReals.html#1494" class="Bound">ℓ</a> <a id="1496" href="SyntheticReals.html#1496" class="Bound">ℓ&#39;</a><a id="1498" class="Symbol">}</a> <a id="1500" class="Symbol">(</a><a id="1501" href="SyntheticReals.html#1501" class="Bound">OF</a> <a id="1504" class="Symbol">:</a> <a id="1506" href="Bundles.html#10651" class="Record">OrderedField</a> <a id="1519" class="Symbol">{</a><a id="1520" href="SyntheticReals.html#1494" class="Bound">ℓ</a><a id="1521" class="Symbol">}</a> <a id="1523" class="Symbol">{</a><a id="1524" href="SyntheticReals.html#1496" class="Bound">ℓ&#39;</a><a id="1526" class="Symbol">})</a> <a id="1529" class="Symbol">→</a>
  <a id="1533" class="Keyword">let</a> <a id="1537" class="Keyword">open</a> <a id="1542" href="Bundles.html#10651" class="Module">OrderedField</a> <a id="1555" href="SyntheticReals.html#1501" class="Bound">OF</a>
  <a id="1560" class="Comment">----------------------------------------------------</a>
  <a id="1615" class="Keyword">in</a> <a id="1618" class="Symbol">(</a><a id="1619" href="Bundles.html#4004" class="Record">IsConstructiveField</a> <a id="1639" href="Bundles.html#10758" class="Field">0f</a> <a id="1642" href="Bundles.html#10761" class="Field">1f</a> <a id="1645" href="Bundles.html#10780" class="Field Operator">_+_</a> <a id="1649" href="Bundles.html#10854" class="Field Operator">_·_</a> <a id="1653" href="Bundles.html#10822" class="Field Operator">-_</a> <a id="1656" href="Bundles.html#11012" class="Function Operator">_#_</a> <a id="1660" href="Bundles.html#11073" class="Field Operator">_⁻¹ᶠ</a><a id="1664" class="Symbol">)</a>
<a id="1666" href="SyntheticReals.html#1426" class="Function">lemma-4-1-12</a> <a id="1679" class="Symbol">{</a><a id="1680" href="SyntheticReals.html#1680" class="Bound">ℓ</a><a id="1681" class="Symbol">}</a> <a id="1683" class="Symbol">{</a><a id="1684" href="SyntheticReals.html#1684" class="Bound">ℓ&#39;</a><a id="1686" class="Symbol">}</a> <a id="1688" href="SyntheticReals.html#1688" class="Bound">OF</a> <a id="1691" class="Symbol">=</a> <a id="1693" class="Keyword">let</a> <a id="1697" class="Comment">-- NOTE: for mentioning the ℓ and ℓ&#39; and not taking them as new &quot;variables&quot; we bring them into scope</a>
  <a id="1800" class="Keyword">open</a> <a id="1805" href="Bundles.html#10651" class="Module">OrderedField</a> <a id="1818" href="SyntheticReals.html#1688" class="Bound">OF</a>
  <a id="1823" class="Keyword">in</a> <a id="1826" class="Keyword">record</a> <a id="1833" class="Comment">-- We need to show that + is #-extensional, and that # is tight.</a>
   <a id="1901" class="Symbol">{</a> <a id="1903" href="SyntheticReals.html#1903" class="Module">OrderedField</a> <a id="1916" href="SyntheticReals.html#1688" class="Bound">OF</a>
   <a id="1922" class="Symbol">;</a> <a id="1924" href="Bundles.html#4673" class="Field">isApartnessRel</a>  <a id="1940" class="Symbol">=</a> <a id="1942" href="MoreAlgebra.html#3671" class="Function">#&#39;-isApartnessRel</a> <a id="1960" href="Bundles.html#8446" class="Function">&lt;-isStrictPartialOrder</a> <a id="1983" class="Comment">-- NOTE: We&#39;ve proved this before</a>
   
     <a id="2026" class="Comment">-- First, assume w + x # y + z. We need to show w # y ∨ x # z.</a>
   <a id="2092" class="Symbol">;</a> <a id="2094" href="Bundles.html#4601" class="Field">+-#-extensional</a> <a id="2110" class="Symbol">=</a> <a id="2112" class="Symbol">λ</a> <a id="2114" class="Keyword">where</a>
                       <a id="2143" class="Comment">-- Consider the case w + x &lt; y + z, so that we can use (†) to obtain w &lt; y ∨ x &lt; z,</a>
                       <a id="2250" class="Comment">--   which gives w # y ∨ x # z in either case.</a>
                       <a id="2320" href="SyntheticReals.html#2320" class="Bound">w</a> <a id="2322" href="SyntheticReals.html#2322" class="Bound">x</a> <a id="2324" href="SyntheticReals.html#2324" class="Bound">y</a> <a id="2326" href="SyntheticReals.html#2326" class="Bound">z</a> <a id="2328" class="Symbol">(</a><a id="2329" href="Cubical.Data.Sum.Base.html#246" class="InductiveConstructor">inl</a> <a id="2333" href="SyntheticReals.html#2333" class="Bound">w+x&lt;y+z</a><a id="2340" class="Symbol">)</a> <a id="2342" class="Symbol">→</a> <a id="2344" href="Cubical.Foundations.Function.html#1093" class="Function Operator">case</a> <a id="2349" href="Bundles.html#10440" class="Function">+-&lt;-extensional</a> <a id="2365" class="Symbol">_</a> <a id="2367" class="Symbol">_</a> <a id="2369" class="Symbol">_</a> <a id="2371" class="Symbol">_</a> <a id="2373" href="SyntheticReals.html#2333" class="Bound">w+x&lt;y+z</a> <a id="2381" href="Cubical.Foundations.Function.html#1093" class="Function Operator">of</a> <a id="2384" class="Symbol">(</a>
                         <a id="2411" class="Symbol">(_</a> <a id="2414" class="Symbol">→</a> <a id="2416" class="Symbol">(</a><a id="2417" href="SyntheticReals.html#2320" class="Bound">w</a> <a id="2419" href="Bundles.html#11012" class="Function Operator">#</a> <a id="2421" href="SyntheticReals.html#2324" class="Bound">y</a><a id="2422" class="Symbol">)</a> <a id="2424" href="SyntheticReals.html#503" class="Datatype Operator">⊎</a> <a id="2426" class="Symbol">(</a><a id="2427" href="SyntheticReals.html#2322" class="Bound">x</a> <a id="2429" href="Bundles.html#11012" class="Function Operator">#</a> <a id="2431" href="SyntheticReals.html#2326" class="Bound">z</a><a id="2432" class="Symbol">))</a> <a id="2435" href="Function.Base.html#4458" class="Function Operator">∋</a> <a id="2437" class="Symbol">λ</a> <a id="2439" class="Comment">-- NOTE: here we had to add a (return-)type annotation to the λ</a>
                         <a id="2528" class="Symbol">{</a> <a id="2530" class="Symbol">(</a><a id="2531" href="Cubical.Data.Sum.Base.html#246" class="InductiveConstructor">inl</a> <a id="2535" href="SyntheticReals.html#2535" class="Bound">w&lt;y</a><a id="2538" class="Symbol">)</a> <a id="2540" class="Symbol">→</a> <a id="2542" href="Cubical.Data.Sum.Base.html#246" class="InductiveConstructor">inl</a> <a id="2546" class="Symbol">(</a><a id="2547" href="Cubical.Data.Sum.Base.html#246" class="InductiveConstructor">inl</a> <a id="2551" href="SyntheticReals.html#2535" class="Bound">w&lt;y</a><a id="2554" class="Symbol">)</a>
                         <a id="2581" class="Symbol">;</a> <a id="2583" class="Symbol">(</a><a id="2584" href="Cubical.Data.Sum.Base.html#264" class="InductiveConstructor">inr</a> <a id="2588" href="SyntheticReals.html#2588" class="Bound">x&lt;z</a><a id="2591" class="Symbol">)</a> <a id="2593" class="Symbol">→</a> <a id="2595" href="Cubical.Data.Sum.Base.html#264" class="InductiveConstructor">inr</a> <a id="2599" class="Symbol">(</a><a id="2600" href="Cubical.Data.Sum.Base.html#246" class="InductiveConstructor">inl</a> <a id="2604" href="SyntheticReals.html#2588" class="Bound">x&lt;z</a><a id="2607" class="Symbol">)</a>
                         <a id="2634" class="Symbol">})</a>
                       <a id="2660" class="Comment">-- The case w + x &gt; y + z is similar.</a>
                       <a id="2721" href="SyntheticReals.html#2721" class="Bound">w</a> <a id="2723" href="SyntheticReals.html#2723" class="Bound">x</a> <a id="2725" href="SyntheticReals.html#2725" class="Bound">y</a> <a id="2727" href="SyntheticReals.html#2727" class="Bound">z</a> <a id="2729" class="Symbol">(</a><a id="2730" href="Cubical.Data.Sum.Base.html#264" class="InductiveConstructor">inr</a> <a id="2734" href="SyntheticReals.html#2734" class="Bound">y+z&lt;w+x</a><a id="2741" class="Symbol">)</a> <a id="2743" class="Symbol">→</a> <a id="2745" href="Cubical.Foundations.Function.html#1093" class="Function Operator">case</a>  <a id="2751" href="Bundles.html#10440" class="Function">+-&lt;-extensional</a> <a id="2767" class="Symbol">_</a> <a id="2769" class="Symbol">_</a> <a id="2771" class="Symbol">_</a> <a id="2773" class="Symbol">_</a> <a id="2775" href="SyntheticReals.html#2734" class="Bound">y+z&lt;w+x</a> <a id="2783" href="Cubical.Foundations.Function.html#1093" class="Function Operator">of</a> <a id="2786" class="Symbol">(</a>
                         <a id="2813" class="Symbol">(_</a> <a id="2816" class="Symbol">→</a> <a id="2818" class="Symbol">(</a><a id="2819" href="SyntheticReals.html#2721" class="Bound">w</a> <a id="2821" href="Bundles.html#11012" class="Function Operator">#</a> <a id="2823" href="SyntheticReals.html#2725" class="Bound">y</a><a id="2824" class="Symbol">)</a> <a id="2826" href="SyntheticReals.html#503" class="Datatype Operator">⊎</a> <a id="2828" class="Symbol">(</a><a id="2829" href="SyntheticReals.html#2723" class="Bound">x</a> <a id="2831" href="Bundles.html#11012" class="Function Operator">#</a> <a id="2833" href="SyntheticReals.html#2727" class="Bound">z</a><a id="2834" class="Symbol">))</a> <a id="2837" href="Function.Base.html#4458" class="Function Operator">∋</a> <a id="2839" class="Symbol">λ</a>
                         <a id="2866" class="Symbol">{</a> <a id="2868" class="Symbol">(</a><a id="2869" href="Cubical.Data.Sum.Base.html#246" class="InductiveConstructor">inl</a> <a id="2873" href="SyntheticReals.html#2873" class="Bound">y&lt;w</a><a id="2876" class="Symbol">)</a> <a id="2878" class="Symbol">→</a> <a id="2880" href="Cubical.Data.Sum.Base.html#246" class="InductiveConstructor">inl</a> <a id="2884" class="Symbol">(</a><a id="2885" href="Cubical.Data.Sum.Base.html#264" class="InductiveConstructor">inr</a> <a id="2889" href="SyntheticReals.html#2873" class="Bound">y&lt;w</a><a id="2892" class="Symbol">)</a>
                         <a id="2919" class="Symbol">;</a> <a id="2921" class="Symbol">(</a><a id="2922" href="Cubical.Data.Sum.Base.html#264" class="InductiveConstructor">inr</a> <a id="2926" href="SyntheticReals.html#2926" class="Bound">z&lt;x</a><a id="2929" class="Symbol">)</a> <a id="2931" class="Symbol">→</a> <a id="2933" href="Cubical.Data.Sum.Base.html#264" class="InductiveConstructor">inr</a> <a id="2937" class="Symbol">(</a><a id="2938" href="Cubical.Data.Sum.Base.html#264" class="InductiveConstructor">inr</a> <a id="2942" href="SyntheticReals.html#2926" class="Bound">z&lt;x</a><a id="2945" class="Symbol">)</a>
                         <a id="2972" class="Symbol">})</a>

     <a id="2981" class="Comment">-- Tightness follows from the fact that ≤ is antisymmetric, combined with the fact</a>
     <a id="3069" class="Comment">--   that ¬(P ∨ Q) is equivalent to ¬P ∧ ¬Q.</a>
   <a id="3117" class="Symbol">;</a> <a id="3119" href="Bundles.html#4482" class="Field">#-tight</a>         <a id="3135" class="Symbol">=</a> <a id="3137" class="Symbol">λ</a> <a id="3139" href="SyntheticReals.html#3139" class="Bound">x</a> <a id="3141" href="SyntheticReals.html#3141" class="Bound">y</a> <a id="3143" href="SyntheticReals.html#3143" class="Bound">¬[x&lt;y]⊎¬[y&lt;x]</a> <a id="3157" class="Symbol">→</a> <a id="3159" class="Keyword">let</a> <a id="3163" class="Symbol">(</a><a id="3164" href="SyntheticReals.html#3164" class="Bound">¬[x&lt;y]</a> <a id="3171" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3173" href="SyntheticReals.html#3173" class="Bound">¬[y&lt;x]</a><a id="3179" class="Symbol">)</a> <a id="3181" class="Symbol">=</a> <a id="3183" href="Utils.html#891" class="Function">deMorgan₂&#39;</a> <a id="3194" href="SyntheticReals.html#3143" class="Bound">¬[x&lt;y]⊎¬[y&lt;x]</a>
                                             <a id="3253" class="Keyword">in</a>  <a id="3257" href="Bundles.html#6369" class="Function">≤-antisym</a> <a id="3267" class="Symbol">_</a> <a id="3269" class="Symbol">_</a> <a id="3271" href="SyntheticReals.html#3173" class="Bound">¬[y&lt;x]</a> <a id="3278" href="SyntheticReals.html#3164" class="Bound">¬[x&lt;y]</a>
   <a id="3288" class="Symbol">}</a>

<a id="3291" class="Comment">-- We will mainly be concerned with ordered fields, as opposed to the more general con-</a>
<a id="3379" class="Comment">-- structive fields. This is because the Archimedean property can be phrased straightforwardly</a>
<a id="3474" class="Comment">-- for ordered fields, as in Section 4.3, and because the ordering relation allows us to define loca-</a>
<a id="3576" class="Comment">-- tors, as in Chapter 6.</a>
<a id="3602" class="Comment">--</a>
<a id="3605" class="Comment">-- We have defined ordered fields, which capture the algebraic structure of the real numbers.</a>

<a id="3700" class="Comment">-- 4.2 Rationals</a>
<a id="3717" class="Comment">-- ...</a>
<a id="3724" class="Comment">-- NOTE: we have in cubical</a>
<a id="3752" class="Comment">--   import Cubical.HITs.Rationals.HITQ</a>
<a id="3792" class="Comment">--     ℚ as a higher inductive type</a>
<a id="3828" class="Comment">--   import Cubical.HITs.Rationals.QuoQ</a>
<a id="3868" class="Comment">--     ℚ as a set quotient of ℤ × ℕ₊₁ (as in the HoTT book)</a>
<a id="3928" class="Comment">--   import Cubical.HITs.Rationals.SigmaQ</a>
<a id="3970" class="Comment">--     ℚ as the set of coprime pairs in ℤ × ℕ₊₁</a>

<a id="4019" class="Keyword">import</a> <a id="4026" href="Cubical.HITs.Rationals.QuoQ.html" class="Module">Cubical.HITs.Rationals.QuoQ</a> <a id="4054" class="Keyword">renaming</a> <a id="4063" class="Symbol">(</a><a id="4064" href="Cubical.HITs.Rationals.QuoQ.Base.html#827" class="Function">ℚ</a> <a id="4066" class="Symbol">to</a> <a id="HITs.Rationals.QuoQ.Base.ℚ"></a><a id="4069" href="SyntheticReals.html#4069" class="Function">ℚ-Carrier</a><a id="4078" class="Symbol">)</a>

<a id="4081" class="Keyword">postulate</a>
  <a id="ℚℓ"></a><a id="4093" href="SyntheticReals.html#4093" class="Postulate">ℚℓ</a> <a id="4096" class="Symbol">:</a> <a id="4098" href="Agda.Primitive.html#523" class="Postulate">Level</a>
  <a id="ℚOF"></a><a id="4106" href="SyntheticReals.html#4106" class="Postulate">ℚOF</a> <a id="4110" class="Symbol">:</a> <a id="4112" href="Bundles.html#10651" class="Record">OrderedField</a> <a id="4125" class="Symbol">{</a><a id="4126" href="SyntheticReals.html#173" class="Primitive">ℓ-zero</a><a id="4132" class="Symbol">}</a> <a id="4134" class="Symbol">{</a><a id="4135" href="SyntheticReals.html#4093" class="Postulate">ℚℓ</a><a id="4137" class="Symbol">}</a>
<a id="4139" class="Comment">{-
ℚ = λ where
  .OrderedField.Carrier        → ℚ-Carrier
  .OrderedField.0f             → 0
  .OrderedField.1f             → 1
  .OrderedField._+_            → _+_
  .OrderedField.-_             → -_
  .OrderedField._·_            → _*_
  .OrderedField.min            → {!!}
  .OrderedField.max            → {!!}
  .OrderedField._&lt;_            → {!!}
  .OrderedField.&lt;-isProp       → {!!}
  .OrderedField._⁻¹ᶠ           → {!!}
  .OrderedField.isOrderedField → {!!}
-}</a>

<a id="4609" class="Comment">-- 4.3 Archimedean property</a>
<a id="4637" class="Comment">--</a>
<a id="4640" class="Comment">-- We now define the notion of Archimedean ordered fields. We phrase this in terms of a certain</a>
<a id="4736" class="Comment">-- interpolation property, that can be defined from the fact that there is a unique morphism of</a>
<a id="4832" class="Comment">-- ordered fields from the rationals to every ordered field.</a>

<a id="4894" class="Comment">-- Lemma 4.3.3. For every ordered field (F, 0 F , 1 F , + F , · F , min F , max F , &lt; F ), there is a unique morphism</a>
<a id="5012" class="Comment">-- i of ordered fields from the rationals to F . Additionally, i preserves &lt; in the sense that for every q, r : Q</a>
<a id="5126" class="Comment">--   q &lt; r ⇒ i (q) &lt; F i (r ).</a>

<a id="5158" class="Comment">-- ∃! : ∀ {ℓ ℓ&#39;} (A : Type ℓ) (B : A → Type ℓ&#39;) → Type (ℓ-max ℓ ℓ&#39;)</a>
<a id="5226" class="Comment">-- ∃! A B = isContr (Σ A B)</a>

<a id="5255" class="Comment">-- isContr&#39; A = Σ[ x ∈ A ] (∀ y → x ≡ y)</a>

<a id="ℚ-IsInitialObject"></a><a id="5297" href="SyntheticReals.html#5297" class="Function">ℚ-IsInitialObject</a> <a id="5315" class="Symbol">:</a> <a id="5317" class="Symbol">∀(</a><a id="5319" href="SyntheticReals.html#5319" class="Bound">OF</a> <a id="5322" class="Symbol">:</a> <a id="5324" href="Bundles.html#10651" class="Record">OrderedField</a> <a id="5337" class="Symbol">{</a><a id="5338" href="SyntheticReals.html#205" class="Generalizable">ℓ</a><a id="5339" class="Symbol">}</a> <a id="5341" class="Symbol">{</a><a id="5342" href="SyntheticReals.html#207" class="Generalizable">ℓ&#39;</a><a id="5344" class="Symbol">})</a> <a id="5347" class="Symbol">→</a> <a id="5349" href="Cubical.Foundations.Id.html#872" class="Function">isContr</a> <a id="5357" class="Symbol">(</a><a id="5358" href="Bundles.html#13798" class="Record">OrderedFieldMor</a> <a id="5374" href="SyntheticReals.html#4106" class="Postulate">ℚOF</a> <a id="5378" href="SyntheticReals.html#5319" class="Bound">OF</a><a id="5380" class="Symbol">)</a>
<a id="5382" href="SyntheticReals.html#5297" class="Function">ℚ-IsInitialObject</a> <a id="5400" href="SyntheticReals.html#5400" class="Bound">OF</a> <a id="5403" class="Symbol">=</a> <a id="5405" class="Symbol">{!!}</a> <a id="5410" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5412" class="Symbol">{!!}</a>

<a id="5418" class="Comment">-- Definition 4.3.5. Let (F, 0 F , 1 F , + F , · F , min F , max F , &lt; F ) be an ordered field, so that we get a</a>
<a id="5531" class="Comment">-- canonical morphism i : Q → F of ordered fields, as in Lemma 4.3.3. We say the ordered field</a>
<a id="5626" class="Comment">-- (F, 0 F , 1 F , + F , · F , min F , max F , &lt; F ) is Archimedean if</a>
<a id="5697" class="Comment">--   (∀x, y : F )(∃q : Q)x &lt; i (q) &lt; y.</a>

<a id="IsArchimedian"></a><a id="5738" href="SyntheticReals.html#5738" class="Function">IsArchimedian</a> <a id="5752" class="Symbol">:</a> <a id="5754" href="Bundles.html#10651" class="Record">OrderedField</a> <a id="5767" class="Symbol">{</a><a id="5768" href="SyntheticReals.html#205" class="Generalizable">ℓ</a><a id="5769" class="Symbol">}</a> <a id="5771" class="Symbol">{</a><a id="5772" href="SyntheticReals.html#207" class="Generalizable">ℓ&#39;</a><a id="5774" class="Symbol">}</a> <a id="5776" class="Symbol">→</a> <a id="5778" href="Agda.Primitive.html#326" class="Primitive">Type</a> <a id="5783" class="Symbol">(</a><a id="5784" href="SyntheticReals.html#142" class="Primitive">ℓ-max</a> <a id="5790" href="SyntheticReals.html#205" class="Generalizable">ℓ</a> <a id="5792" href="SyntheticReals.html#207" class="Generalizable">ℓ&#39;</a><a id="5794" class="Symbol">)</a>
<a id="5796" href="SyntheticReals.html#5738" class="Function">IsArchimedian</a> <a id="5810" href="SyntheticReals.html#5810" class="Bound">OF</a> <a id="5813" class="Symbol">=</a> <a id="5815" class="Keyword">let</a> <a id="5819" class="Symbol">(</a><a id="5820" href="Bundles.html#13949" class="InductiveConstructor">orderedfieldmor</a> <a id="5836" href="SyntheticReals.html#5836" class="Bound">i</a> <a id="5838" class="Symbol">_)</a> <a id="5841" class="Symbol">=</a> <a id="5843" href="Cubical.Foundations.Id.html#983" class="Field">fst</a> <a id="5847" class="Symbol">(</a><a id="5848" href="SyntheticReals.html#5297" class="Function">ℚ-IsInitialObject</a> <a id="5866" href="SyntheticReals.html#5810" class="Bound">OF</a><a id="5868" class="Symbol">)</a>
                       <a id="5893" class="Keyword">open</a> <a id="5898" href="Bundles.html#10651" class="Module">OrderedField</a> <a id="5911" href="SyntheticReals.html#5810" class="Bound">OF</a>
                       <a id="5937" href="SyntheticReals.html#5937" class="Bound">ℚ</a> <a id="5939" class="Symbol">=</a> <a id="5941" href="Bundles.html#10737" class="Field">OrderedField.Carrier</a> <a id="5962" href="SyntheticReals.html#4106" class="Postulate">ℚOF</a>
                   <a id="5985" class="Keyword">in</a> <a id="5988" class="Symbol">∀</a> <a id="5990" href="SyntheticReals.html#5990" class="Bound">x</a> <a id="5992" href="SyntheticReals.html#5992" class="Bound">y</a> <a id="5994" class="Symbol">→</a> <a id="5996" href="Cubical.Data.Sigma.Base.html#709" class="Function">∃[</a> <a id="5999" href="SyntheticReals.html#5999" class="Bound">q</a> <a id="6001" href="Cubical.Data.Sigma.Base.html#709" class="Function">∈</a> <a id="6003" href="SyntheticReals.html#5937" class="Bound">ℚ</a> <a id="6005" href="Cubical.Data.Sigma.Base.html#709" class="Function">]</a> <a id="6007" class="Symbol">(</a><a id="6008" href="SyntheticReals.html#5990" class="Bound">x</a> <a id="6010" href="Bundles.html#10938" class="Field Operator">&lt;</a> <a id="6012" href="SyntheticReals.html#5836" class="Bound">i</a> <a id="6014" href="SyntheticReals.html#5999" class="Bound">q</a><a id="6015" class="Symbol">)</a> <a id="6017" href="SyntheticReals.html#570" class="Function Operator">×</a> <a id="6019" class="Symbol">(</a><a id="6020" href="SyntheticReals.html#5836" class="Bound">i</a> <a id="6022" href="SyntheticReals.html#5999" class="Bound">q</a> <a id="6024" href="Bundles.html#10938" class="Field Operator">&lt;</a> <a id="6026" href="SyntheticReals.html#5992" class="Bound">y</a><a id="6027" class="Symbol">)</a>
                   
<a id="6049" class="Comment">-- If the ordered field is clear from the context, we will identify rationals q : Q with their in-</a>
<a id="6148" class="Comment">-- clusion i (q) in the ordered field, so that we may also say that (F, 0 F , 1 F , + F , · F , min F , max F , &lt; F )</a>
<a id="6266" class="Comment">-- is Archimedean if</a>
<a id="6287" class="Comment">-- (∀x, y : F )(∃q : Q)x &lt; q &lt; y.</a>

<a id="6322" class="Comment">-- Example 4.3.6. In an Archimedean ordered field, all numbers are bounded by rationals. That</a>
<a id="6416" class="Comment">-- is, for a given x : F , there exist q, r : Q with q &lt; x &lt; r .</a>

<a id="Example-4-3-6"></a><a id="6482" href="SyntheticReals.html#6482" class="Function">Example-4-3-6</a> <a id="6496" class="Symbol">:</a> <a id="6498" class="Symbol">(</a><a id="6499" href="SyntheticReals.html#6499" class="Bound">OF</a> <a id="6502" class="Symbol">:</a> <a id="6504" href="Bundles.html#10651" class="Record">OrderedField</a> <a id="6517" class="Symbol">{</a><a id="6518" href="SyntheticReals.html#205" class="Generalizable">ℓ</a><a id="6519" class="Symbol">}</a> <a id="6521" class="Symbol">{</a><a id="6522" href="SyntheticReals.html#207" class="Generalizable">ℓ&#39;</a><a id="6524" class="Symbol">})</a>
              <a id="6541" class="Symbol">→</a> <a id="6543" href="SyntheticReals.html#5738" class="Function">IsArchimedian</a> <a id="6557" href="SyntheticReals.html#6499" class="Bound">OF</a>
              <a id="6574" class="Symbol">→</a> <a id="6576" class="Keyword">let</a> <a id="6580" class="Keyword">open</a> <a id="6585" href="Bundles.html#10651" class="Module">OrderedField</a> <a id="6598" href="SyntheticReals.html#6499" class="Bound">OF</a> <a id="6601" class="Keyword">renaming</a> <a id="6610" class="Symbol">(</a><a id="6611" href="Bundles.html#10737" class="Field">Carrier</a> <a id="6619" class="Symbol">to</a> <a id="OrderedField.Carrier"></a><a id="6622" href="SyntheticReals.html#6622" class="Field">F</a><a id="6623" class="Symbol">)</a>
                    <a id="6645" class="Symbol">(</a><a id="6646" href="Bundles.html#13949" class="InductiveConstructor">orderedfieldmor</a> <a id="6662" href="SyntheticReals.html#6662" class="Bound">i</a> <a id="6664" class="Symbol">_)</a> <a id="6667" class="Symbol">=</a> <a id="6669" href="Cubical.Foundations.Id.html#983" class="Field">fst</a> <a id="6673" class="Symbol">(</a><a id="6674" href="SyntheticReals.html#5297" class="Function">ℚ-IsInitialObject</a> <a id="6692" href="SyntheticReals.html#6499" class="Bound">OF</a><a id="6694" class="Symbol">)</a>
                    <a id="6716" href="SyntheticReals.html#6716" class="Bound">ℚ</a> <a id="6718" class="Symbol">=</a> <a id="6720" href="Bundles.html#10737" class="Field">OrderedField.Carrier</a> <a id="6741" href="SyntheticReals.html#4106" class="Postulate">ℚOF</a>
                <a id="6761" class="Keyword">in</a> <a id="6764" class="Symbol">∀(</a><a id="6766" href="SyntheticReals.html#6766" class="Bound">x</a> <a id="6768" class="Symbol">:</a> <a id="6770" href="SyntheticReals.html#6622" class="Field">F</a><a id="6771" class="Symbol">)</a> <a id="6773" class="Symbol">→</a> <a id="6775" class="Symbol">(</a><a id="6776" href="Cubical.Data.Sigma.Base.html#709" class="Function">∃[</a> <a id="6779" href="SyntheticReals.html#6779" class="Bound">q</a> <a id="6781" href="Cubical.Data.Sigma.Base.html#709" class="Function">∈</a> <a id="6783" href="SyntheticReals.html#6716" class="Bound">ℚ</a> <a id="6785" href="Cubical.Data.Sigma.Base.html#709" class="Function">]</a> <a id="6787" href="SyntheticReals.html#6662" class="Bound">i</a> <a id="6789" href="SyntheticReals.html#6779" class="Bound">q</a> <a id="6791" href="Bundles.html#10938" class="Field Operator">&lt;</a> <a id="6793" href="SyntheticReals.html#6766" class="Bound">x</a><a id="6794" class="Symbol">)</a> <a id="6796" href="SyntheticReals.html#570" class="Function Operator">×</a> <a id="6798" class="Symbol">(</a><a id="6799" href="Cubical.Data.Sigma.Base.html#709" class="Function">∃[</a> <a id="6802" href="SyntheticReals.html#6802" class="Bound">r</a> <a id="6804" href="Cubical.Data.Sigma.Base.html#709" class="Function">∈</a> <a id="6806" href="SyntheticReals.html#6716" class="Bound">ℚ</a> <a id="6808" href="Cubical.Data.Sigma.Base.html#709" class="Function">]</a> <a id="6810" href="SyntheticReals.html#6766" class="Bound">x</a> <a id="6812" href="Bundles.html#10938" class="Field Operator">&lt;</a> <a id="6814" href="SyntheticReals.html#6662" class="Bound">i</a> <a id="6816" href="SyntheticReals.html#6802" class="Bound">r</a><a id="6817" class="Symbol">)</a>
<a id="6819" class="Comment">-- This follows from applying the Archimedean property to x − 1 &lt; x and x &lt; x + 1.</a>
<a id="6902" href="SyntheticReals.html#6482" class="Function">Example-4-3-6</a> <a id="6916" href="SyntheticReals.html#6916" class="Bound">OF</a> <a id="6919" href="SyntheticReals.html#6919" class="Bound">isArchimedian</a> <a id="6933" class="Symbol">=</a> <a id="6935" class="Symbol">{!!}</a>

<a id="6941" class="Comment">-- 4.4 Cauchy completeness of real numbers</a>
<a id="6984" class="Comment">--</a>
<a id="6987" class="Comment">-- We focus on Cauchy completeness, rather than Dedekind or Dedekind-MacNeille completeness,</a>
<a id="7080" class="Comment">-- as we will focus on the computation of digit expansions, for which Cauchy completeness suffices.</a>

<a id="7181" class="Comment">-- In order to state that an ordered field is Cauchy complete, we need to define when sequences</a>
<a id="7277" class="Comment">-- are Cauchy, and when a sequence has a limit. We also take the opportunity to define</a>
<a id="7364" class="Comment">-- the set of Cauchy reals in Definition 4.4.9. Surprisingly, this ordered field cannot be shown to</a>
<a id="7464" class="Comment">-- be Cauchy complete.</a>

<a id="7488" class="Comment">-- NOTE: in the following we make use of ℚ⁺ a few times. Maybe this should be a primitive?</a>

<a id="7580" class="Comment">-- Fix an ordered field (F, 0 F , 1 F , + F , · F , min F , max F , &lt; F ).</a>
<a id="7655" class="Keyword">module</a> <a id="7662" href="SyntheticReals.html#7662" class="Module">_</a> <a id="7664" class="Symbol">(</a><a id="7665" href="SyntheticReals.html#7665" class="Bound">OF</a> <a id="7668" class="Symbol">:</a> <a id="7670" href="Bundles.html#10651" class="Record">OrderedField</a> <a id="7683" class="Symbol">{</a><a id="7684" href="SyntheticReals.html#205" class="Generalizable">ℓ</a><a id="7685" class="Symbol">}</a> <a id="7687" class="Symbol">{</a><a id="7688" href="SyntheticReals.html#207" class="Generalizable">ℓ&#39;</a><a id="7690" class="Symbol">})</a> <a id="7693" class="Keyword">where</a>
  <a id="7701" class="Keyword">open</a> <a id="7706" href="Bundles.html#10651" class="Module">OrderedField</a> <a id="7719" href="SyntheticReals.html#7665" class="Bound">OF</a> <a id="7722" class="Keyword">renaming</a> <a id="7731" class="Symbol">(</a><a id="7732" href="Bundles.html#10737" class="Field">Carrier</a> <a id="7740" class="Symbol">to</a> <a id="OrderedField.Carrier"></a><a id="7743" href="SyntheticReals.html#7743" class="Field">F</a><a id="7744" class="Symbol">)</a>
  <a id="7748" class="Comment">-- module ℚ = OrderedField ℚ</a>
  <a id="7779" class="Keyword">open</a> <a id="7784" href="Bundles.html#10651" class="Module">OrderedField</a> <a id="7797" href="SyntheticReals.html#4106" class="Postulate">ℚOF</a> <a id="7801" class="Keyword">using</a> <a id="7807" class="Symbol">()</a> <a id="7810" class="Keyword">renaming</a> <a id="7819" class="Symbol">(</a><a id="7820" href="Bundles.html#10938" class="Field Operator">_&lt;_</a> <a id="7824" class="Symbol">to</a> <a id="OrderedField._&lt;_"></a><a id="7827" href="SyntheticReals.html#7827" class="Field Operator">_&lt;ᵣ_</a><a id="7831" class="Symbol">;</a> <a id="7833" href="Bundles.html#10758" class="Field">0f</a> <a id="7836" class="Symbol">to</a> <a id="OrderedField.0f"></a><a id="7839" href="SyntheticReals.html#7839" class="Field">0ᵣ</a><a id="7841" class="Symbol">)</a>
  <a id="7845" href="SyntheticReals.html#7845" class="Function">ℚ</a> <a id="7847" class="Symbol">=</a> <a id="7849" href="Bundles.html#10737" class="Field">OrderedField.Carrier</a> <a id="7870" href="SyntheticReals.html#4106" class="Postulate">ℚOF</a>
  <a id="7876" href="SyntheticReals.html#7876" class="Function">iᵣ</a> <a id="7879" class="Symbol">=</a> <a id="7881" href="Bundles.html#14033" class="Field">OrderedFieldMor.fun</a> <a id="7901" class="Symbol">(</a><a id="7902" href="Cubical.Foundations.Id.html#983" class="Field">fst</a> <a id="7906" class="Symbol">(</a><a id="7907" href="SyntheticReals.html#5297" class="Function">ℚ-IsInitialObject</a> <a id="7925" href="SyntheticReals.html#7665" class="Bound">OF</a><a id="7927" class="Symbol">))</a>
  <a id="7932" class="Keyword">open</a> <a id="7937" class="Keyword">import</a> <a id="7944" href="Data.Nat.Base.html" class="Module">Data.Nat.Base</a> <a id="7958" class="Keyword">using</a> <a id="7964" class="Symbol">(</a><a id="7965" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="7966" class="Symbol">)</a> <a id="7968" class="Keyword">renaming</a> <a id="7977" class="Symbol">(</a><a id="7978" href="Data.Nat.Base.html#1396" class="Datatype Operator">_≤_</a> <a id="7982" class="Symbol">to</a> <a id="Nat.Base._≤_"></a><a id="7985" href="SyntheticReals.html#7985" class="Datatype Operator">_≤ₙ_</a><a id="7989" class="Symbol">)</a>

  <a id="7994" class="Comment">-- We get a notion of distance, given by the absolute value as</a>
  <a id="8059" class="Comment">--   |x − y| := max F (x − y, −(x − y)).</a>

  <a id="8103" href="SyntheticReals.html#8103" class="Function">distance</a> <a id="8112" class="Symbol">:</a> <a id="8114" class="Symbol">∀(</a><a id="8116" href="SyntheticReals.html#8116" class="Bound">x</a> <a id="8118" href="SyntheticReals.html#8118" class="Bound">y</a> <a id="8120" class="Symbol">:</a> <a id="8122" href="SyntheticReals.html#7743" class="Field">F</a><a id="8123" class="Symbol">)</a> <a id="8125" class="Symbol">→</a> <a id="8127" href="SyntheticReals.html#7743" class="Field">F</a>
  <a id="8131" href="SyntheticReals.html#8103" class="Function">distance</a> <a id="8140" href="SyntheticReals.html#8140" class="Bound">x</a> <a id="8142" href="SyntheticReals.html#8142" class="Bound">y</a> <a id="8144" class="Symbol">=</a> <a id="8146" href="Bundles.html#10900" class="Field">max</a> <a id="8150" class="Symbol">(</a><a id="8151" href="SyntheticReals.html#8140" class="Bound">x</a> <a id="8153" href="Cubical.Structures.Group.Base.html#529" class="Function Operator">-</a> <a id="8155" href="SyntheticReals.html#8142" class="Bound">y</a><a id="8156" class="Symbol">)</a> <a id="8158" class="Symbol">(</a><a id="8159" href="Bundles.html#10822" class="Field Operator">-</a> <a id="8161" class="Symbol">(</a><a id="8162" href="SyntheticReals.html#8140" class="Bound">x</a> <a id="8164" href="Cubical.Structures.Group.Base.html#529" class="Function Operator">-</a> <a id="8166" href="SyntheticReals.html#8142" class="Bound">y</a><a id="8167" class="Symbol">))</a>

  <a id="8173" class="Comment">-- Consider a sequence x : N → F of elements of F . Classically, we may state that x is Cauchy as</a>
  <a id="8273" class="Comment">-- (∀ε : Q + )(∃N : N)(∀m, n : N)m, n ≥ N ⇒ |x m − x n | &lt; ε,</a>
  <a id="8337" href="SyntheticReals.html#8337" class="Function">IsCauchy</a> <a id="8346" class="Symbol">:</a> <a id="8348" class="Symbol">(</a><a id="8349" href="SyntheticReals.html#8349" class="Bound">x</a> <a id="8351" class="Symbol">:</a> <a id="8353" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="8355" class="Symbol">→</a> <a id="8357" href="SyntheticReals.html#7743" class="Field">F</a><a id="8358" class="Symbol">)</a> <a id="8360" class="Symbol">→</a> <a id="8362" href="Agda.Primitive.html#326" class="Primitive">Type</a> <a id="8367" class="Symbol">(</a><a id="8368" href="SyntheticReals.html#142" class="Primitive">ℓ-max</a> <a id="8374" href="SyntheticReals.html#7688" class="Bound">ℓ&#39;</a> <a id="8377" href="SyntheticReals.html#4093" class="Postulate">ℚℓ</a><a id="8379" class="Symbol">)</a>
  <a id="8383" href="SyntheticReals.html#8337" class="Function">IsCauchy</a> <a id="8392" href="SyntheticReals.html#8392" class="Bound">x</a> <a id="8394" class="Symbol">=</a> <a id="8396" class="Symbol">∀(</a><a id="8398" href="SyntheticReals.html#8398" class="Bound">ε</a> <a id="8400" class="Symbol">:</a> <a id="8402" href="SyntheticReals.html#7845" class="Function">ℚ</a><a id="8403" class="Symbol">)</a> <a id="8405" class="Symbol">→</a> <a id="8407" href="SyntheticReals.html#7839" class="Function">0ᵣ</a> <a id="8410" href="SyntheticReals.html#7827" class="Function Operator">&lt;ᵣ</a> <a id="8413" href="SyntheticReals.html#8398" class="Bound">ε</a> <a id="8415" class="Symbol">→</a> <a id="8417" href="Cubical.Data.Sigma.Base.html#709" class="Function">∃[</a> <a id="8420" href="SyntheticReals.html#8420" class="Bound">N</a> <a id="8422" href="Cubical.Data.Sigma.Base.html#709" class="Function">∈</a> <a id="8424" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="8426" href="Cubical.Data.Sigma.Base.html#709" class="Function">]</a> <a id="8428" class="Symbol">∀(</a><a id="8430" href="SyntheticReals.html#8430" class="Bound">m</a> <a id="8432" href="SyntheticReals.html#8432" class="Bound">n</a> <a id="8434" class="Symbol">:</a> <a id="8436" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="8437" class="Symbol">)</a> <a id="8439" class="Symbol">→</a> <a id="8441" href="SyntheticReals.html#8420" class="Bound">N</a> <a id="8443" href="SyntheticReals.html#7985" class="Datatype Operator">≤ₙ</a> <a id="8446" href="SyntheticReals.html#8430" class="Bound">m</a> <a id="8448" class="Symbol">→</a> <a id="8450" href="SyntheticReals.html#8420" class="Bound">N</a> <a id="8452" href="SyntheticReals.html#7985" class="Datatype Operator">≤ₙ</a> <a id="8455" href="SyntheticReals.html#8432" class="Bound">n</a> <a id="8457" class="Symbol">→</a> <a id="8459" href="SyntheticReals.html#8103" class="Function">distance</a> <a id="8468" class="Symbol">(</a><a id="8469" href="SyntheticReals.html#8392" class="Bound">x</a> <a id="8471" href="SyntheticReals.html#8430" class="Bound">m</a><a id="8472" class="Symbol">)</a> <a id="8474" class="Symbol">(</a><a id="8475" href="SyntheticReals.html#8392" class="Bound">x</a> <a id="8477" href="SyntheticReals.html#8432" class="Bound">n</a><a id="8478" class="Symbol">)</a> <a id="8480" href="Bundles.html#10938" class="Field Operator">&lt;</a> <a id="8482" href="SyntheticReals.html#7876" class="Function">iᵣ</a> <a id="8485" href="SyntheticReals.html#8398" class="Bound">ε</a>

  <a id="8490" class="Comment">-- We can interpret the quantifiers as in Definition 2.4.5.</a>
  <a id="8552" class="Comment">-- NOTE: this is the case, since `∃ A B = ∥ Σ A B ∥`</a>

  <a id="8608" class="Comment">-- Following a propositions-as-types interpretation, we may also state that x is Cauchy as the</a>
  <a id="8705" class="Comment">-- structure</a>
  <a id="8720" class="Comment">-- (Πε : Q + )(ΣN : N)(Πm, n : N)m, n ≥ N → |x m − x n | &lt; ε.</a>

  <a id="8785" class="Comment">-- The dependent sum represents a choice of index N for every error ε, and so we have arrived at the following definition.</a>

  <a id="8911" class="Comment">-- Definition 4.4.1.</a>
  <a id="8934" class="Comment">-- For a sequence of reals x : N → F , a a modulus of Cauchy convergence is a map M : Q + → N such that</a>
  <a id="9040" class="Comment">-- (∀ε : Q + )(∀m, n : N)m, n ≥ M (ε) ⇒ |x m − x n | &lt; ε.</a>

  <a id="9101" class="Comment">-- NOTE: do we already call these x &quot;reals&quot; ?</a>
  <a id="9149" class="Comment">-- NOTE: we are using the Modulus-type `((y : ℚ) → {{0ᵣ &lt;ᵣ y}} → ℕ)` a few times and might abbreviate it</a>
  
  <a id="9259" href="SyntheticReals.html#9259" class="Function">IsModulusOfCauchyConvergence</a> <a id="9288" class="Symbol">:</a> <a id="9290" class="Symbol">(</a><a id="9291" href="SyntheticReals.html#9291" class="Bound">x</a> <a id="9293" class="Symbol">:</a> <a id="9295" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="9297" class="Symbol">→</a> <a id="9299" href="SyntheticReals.html#7743" class="Field">F</a><a id="9300" class="Symbol">)</a> <a id="9302" class="Symbol">→</a> <a id="9304" class="Symbol">(</a><a id="9305" href="SyntheticReals.html#9305" class="Bound">M</a> <a id="9307" class="Symbol">:</a> <a id="9309" class="Symbol">((</a><a id="9311" href="SyntheticReals.html#9311" class="Bound">y</a> <a id="9313" class="Symbol">:</a> <a id="9315" href="SyntheticReals.html#7845" class="Function">ℚ</a><a id="9316" class="Symbol">)</a> <a id="9318" class="Symbol">→</a> <a id="9320" class="Symbol">{{</a><a id="9322" href="SyntheticReals.html#7839" class="Function">0ᵣ</a> <a id="9325" href="SyntheticReals.html#7827" class="Function Operator">&lt;ᵣ</a> <a id="9328" href="SyntheticReals.html#9311" class="Bound">y</a><a id="9329" class="Symbol">}}</a> <a id="9332" class="Symbol">→</a> <a id="9334" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="9335" class="Symbol">))</a> <a id="9338" class="Symbol">→</a> <a id="9340" href="Agda.Primitive.html#326" class="Primitive">Type</a> <a id="9345" class="Symbol">(</a><a id="9346" href="SyntheticReals.html#142" class="Primitive">ℓ-max</a> <a id="9352" href="SyntheticReals.html#7688" class="Bound">ℓ&#39;</a> <a id="9355" href="SyntheticReals.html#4093" class="Postulate">ℚℓ</a><a id="9357" class="Symbol">)</a>
  <a id="9361" href="SyntheticReals.html#9259" class="Function">IsModulusOfCauchyConvergence</a> <a id="9390" href="SyntheticReals.html#9390" class="Bound">x</a> <a id="9392" href="SyntheticReals.html#9392" class="Bound">M</a> <a id="9394" class="Symbol">=</a> <a id="9396" class="Symbol">∀(</a><a id="9398" href="SyntheticReals.html#9398" class="Bound">ε</a> <a id="9400" class="Symbol">:</a> <a id="9402" href="SyntheticReals.html#7845" class="Function">ℚ</a><a id="9403" class="Symbol">)</a> <a id="9405" class="Symbol">→</a> <a id="9407" class="Symbol">(</a><a id="9408" href="SyntheticReals.html#9408" class="Bound">p</a> <a id="9410" class="Symbol">:</a> <a id="9412" href="SyntheticReals.html#7839" class="Function">0ᵣ</a> <a id="9415" href="SyntheticReals.html#7827" class="Function Operator">&lt;ᵣ</a> <a id="9418" href="SyntheticReals.html#9398" class="Bound">ε</a><a id="9419" class="Symbol">)</a> <a id="9421" class="Symbol">→</a> <a id="9423" class="Symbol">∀(</a><a id="9425" href="SyntheticReals.html#9425" class="Bound">m</a> <a id="9427" href="SyntheticReals.html#9427" class="Bound">n</a> <a id="9429" class="Symbol">:</a> <a id="9431" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="9432" class="Symbol">)</a>
                                   <a id="9469" class="Symbol">→</a> <a id="9471" class="Keyword">let</a> <a id="9475" class="Keyword">instance</a> <a id="9484" href="SyntheticReals.html#9484" class="Bound">_</a> <a id="9486" class="Symbol">=</a> <a id="9488" href="SyntheticReals.html#9408" class="Bound">p</a>
                                     <a id="9527" class="Keyword">in</a> <a id="9530" href="SyntheticReals.html#9392" class="Bound">M</a> <a id="9532" href="SyntheticReals.html#9398" class="Bound">ε</a> <a id="9534" href="SyntheticReals.html#7985" class="Datatype Operator">≤ₙ</a> <a id="9537" href="SyntheticReals.html#9425" class="Bound">m</a> <a id="9539" class="Symbol">→</a> <a id="9541" href="SyntheticReals.html#9392" class="Bound">M</a> <a id="9543" href="SyntheticReals.html#9398" class="Bound">ε</a> <a id="9545" href="SyntheticReals.html#7985" class="Datatype Operator">≤ₙ</a> <a id="9548" href="SyntheticReals.html#9427" class="Bound">n</a> <a id="9550" class="Symbol">→</a> <a id="9552" href="SyntheticReals.html#8103" class="Function">distance</a> <a id="9561" class="Symbol">(</a><a id="9562" href="SyntheticReals.html#9390" class="Bound">x</a> <a id="9564" href="SyntheticReals.html#9425" class="Bound">m</a><a id="9565" class="Symbol">)</a> <a id="9567" class="Symbol">(</a><a id="9568" href="SyntheticReals.html#9390" class="Bound">x</a> <a id="9570" href="SyntheticReals.html#9427" class="Bound">n</a><a id="9571" class="Symbol">)</a> <a id="9573" href="Bundles.html#10938" class="Field Operator">&lt;</a> <a id="9575" href="SyntheticReals.html#7876" class="Function">iᵣ</a> <a id="9578" href="SyntheticReals.html#9398" class="Bound">ε</a>

  <a id="9583" class="Comment">-- In constructive mathematics, we typically use such sequences with modulus, for example,</a>
  <a id="9676" class="Comment">-- because they can sometimes be used to compute limits of Cauchy sequences, avoiding choice axioms.</a>

  <a id="9780" class="Comment">-- Definition 4.4.2.</a>
  <a id="9803" class="Comment">-- A number l : F is the limit of a sequence x : N → F if the sequence</a>
  <a id="9876" class="Comment">-- converges to l in the usual sense:</a>
  <a id="9916" class="Comment">--   (∀ε : Q + )(∃N : N)(∀n : N)n ≥ N ⇒ |x n − l | &lt; ε.</a>

  <a id="9975" href="SyntheticReals.html#9975" class="Function">IsLimit</a> <a id="9983" class="Symbol">:</a> <a id="9985" class="Symbol">(</a><a id="9986" href="SyntheticReals.html#9986" class="Bound">x</a> <a id="9988" class="Symbol">:</a> <a id="9990" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="9992" class="Symbol">→</a> <a id="9994" href="SyntheticReals.html#7743" class="Field">F</a><a id="9995" class="Symbol">)</a> <a id="9997" class="Symbol">→</a> <a id="9999" class="Symbol">(</a><a id="10000" href="SyntheticReals.html#10000" class="Bound">l</a> <a id="10002" class="Symbol">:</a> <a id="10004" href="SyntheticReals.html#7743" class="Field">F</a><a id="10005" class="Symbol">)</a> <a id="10007" class="Symbol">→</a> <a id="10009" href="Agda.Primitive.html#326" class="Primitive">Type</a> <a id="10014" class="Symbol">(</a><a id="10015" href="SyntheticReals.html#142" class="Primitive">ℓ-max</a> <a id="10021" href="SyntheticReals.html#7688" class="Bound">ℓ&#39;</a> <a id="10024" href="SyntheticReals.html#4093" class="Postulate">ℚℓ</a><a id="10026" class="Symbol">)</a>
  <a id="10030" href="SyntheticReals.html#9975" class="Function">IsLimit</a> <a id="10038" href="SyntheticReals.html#10038" class="Bound">x</a> <a id="10040" href="SyntheticReals.html#10040" class="Bound">l</a> <a id="10042" class="Symbol">=</a> <a id="10044" class="Symbol">∀(</a><a id="10046" href="SyntheticReals.html#10046" class="Bound">ε</a> <a id="10048" class="Symbol">:</a> <a id="10050" href="SyntheticReals.html#7845" class="Function">ℚ</a><a id="10051" class="Symbol">)</a> <a id="10053" class="Symbol">→</a> <a id="10055" class="Symbol">(</a><a id="10056" href="SyntheticReals.html#7839" class="Function">0ᵣ</a> <a id="10059" href="SyntheticReals.html#7827" class="Function Operator">&lt;ᵣ</a> <a id="10062" href="SyntheticReals.html#10046" class="Bound">ε</a><a id="10063" class="Symbol">)</a> <a id="10065" class="Symbol">→</a> <a id="10067" href="Cubical.Data.Sigma.Base.html#709" class="Function">∃[</a> <a id="10070" href="SyntheticReals.html#10070" class="Bound">N</a> <a id="10072" href="Cubical.Data.Sigma.Base.html#709" class="Function">∈</a> <a id="10074" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="10076" href="Cubical.Data.Sigma.Base.html#709" class="Function">]</a> <a id="10078" class="Symbol">∀(</a><a id="10080" href="SyntheticReals.html#10080" class="Bound">n</a> <a id="10082" class="Symbol">:</a> <a id="10084" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="10085" class="Symbol">)</a> <a id="10087" class="Symbol">→</a> <a id="10089" href="SyntheticReals.html#10070" class="Bound">N</a> <a id="10091" href="SyntheticReals.html#7985" class="Datatype Operator">≤ₙ</a> <a id="10094" href="SyntheticReals.html#10080" class="Bound">n</a> <a id="10096" class="Symbol">→</a> <a id="10098" href="SyntheticReals.html#8103" class="Function">distance</a> <a id="10107" class="Symbol">(</a><a id="10108" href="SyntheticReals.html#10038" class="Bound">x</a> <a id="10110" href="SyntheticReals.html#10080" class="Bound">n</a><a id="10111" class="Symbol">)</a> <a id="10113" href="SyntheticReals.html#10040" class="Bound">l</a> <a id="10115" href="Bundles.html#10938" class="Field Operator">&lt;</a> <a id="10117" href="SyntheticReals.html#7876" class="Function">iᵣ</a> <a id="10120" href="SyntheticReals.html#10046" class="Bound">ε</a>

  <a id="10125" class="Comment">-- Remark 4.4.3. We do not consider the statement of convergence in propositions-as-types</a>
  <a id="10217" class="Comment">-- </a>
  <a id="10223" class="Comment">--   (Πε : Q + )(ΣN : N)(Πn : N)n ≥ N → |x n − l | &lt; ε,</a>
  <a id="10281" class="Comment">--   </a>
  <a id="10289" class="Comment">-- because if the sequence has a modulus of Cauchy convergence M, then λε.M (ε/2) is a</a>
  <a id="10378" class="Comment">-- modulus of convergence to the limit l, so that we get an element of the above type.</a>

  <a id="10468" class="Comment">-- Definition 4.4.4.</a>
  <a id="10491" class="Comment">-- The ordered field (F, 0 F , 1 F , + F , · F , min F , max F , &lt; F ) is said to be Cauchy complete</a>
  <a id="10594" class="Comment">-- if for every sequence x with modulus of Cauchy convergence M, we have a limit of x.</a>
  <a id="10683" class="Comment">-- In other words, an ordered field is Cauchy complete iff from a sequence–modulus pair (x, M), we can compute a limit of x.</a>
  
  <a id="10813" href="SyntheticReals.html#10813" class="Function">IsCauchyComplete</a> <a id="10830" class="Symbol">:</a> <a id="10832" href="Agda.Primitive.html#326" class="Primitive">Type</a> <a id="10837" class="Symbol">(</a><a id="10838" href="SyntheticReals.html#142" class="Primitive">ℓ-max</a> <a id="10844" class="Symbol">(</a><a id="10845" href="SyntheticReals.html#142" class="Primitive">ℓ-max</a> <a id="10851" href="SyntheticReals.html#7684" class="Bound">ℓ</a> <a id="10853" href="SyntheticReals.html#7688" class="Bound">ℓ&#39;</a><a id="10855" class="Symbol">)</a> <a id="10857" href="SyntheticReals.html#4093" class="Postulate">ℚℓ</a><a id="10859" class="Symbol">)</a>
  <a id="10863" href="SyntheticReals.html#10813" class="Function">IsCauchyComplete</a> <a id="10880" class="Symbol">=</a> <a id="10882" class="Symbol">(</a><a id="10883" href="SyntheticReals.html#10883" class="Bound">x</a> <a id="10885" class="Symbol">:</a> <a id="10887" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="10889" class="Symbol">→</a> <a id="10891" href="SyntheticReals.html#7743" class="Field">F</a><a id="10892" class="Symbol">)</a>
                   <a id="10913" class="Symbol">→</a> <a id="10915" class="Symbol">(</a><a id="10916" href="SyntheticReals.html#10916" class="Bound">M</a> <a id="10918" class="Symbol">:</a> <a id="10920" class="Symbol">((</a><a id="10922" href="SyntheticReals.html#10922" class="Bound">y</a> <a id="10924" class="Symbol">:</a> <a id="10926" href="SyntheticReals.html#7845" class="Function">ℚ</a><a id="10927" class="Symbol">)</a> <a id="10929" class="Symbol">→</a> <a id="10931" class="Symbol">{{</a><a id="10933" href="SyntheticReals.html#7839" class="Function">0ᵣ</a> <a id="10936" href="SyntheticReals.html#7827" class="Function Operator">&lt;ᵣ</a> <a id="10939" href="SyntheticReals.html#10922" class="Bound">y</a><a id="10940" class="Symbol">}}</a> <a id="10943" class="Symbol">→</a> <a id="10945" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="10946" class="Symbol">))</a>
                   <a id="10968" class="Symbol">→</a> <a id="10970" href="SyntheticReals.html#9259" class="Function">IsModulusOfCauchyConvergence</a> <a id="10999" href="SyntheticReals.html#10883" class="Bound">x</a> <a id="11001" href="SyntheticReals.html#10916" class="Bound">M</a>
                   <a id="11022" class="Symbol">→</a> <a id="11024" href="Cubical.Core.Primitives.html#6306" class="Function">Σ[</a> <a id="11027" href="SyntheticReals.html#11027" class="Bound">l</a> <a id="11029" href="Cubical.Core.Primitives.html#6306" class="Function">∈</a> <a id="11031" href="SyntheticReals.html#7743" class="Field">F</a> <a id="11033" href="Cubical.Core.Primitives.html#6306" class="Function">]</a> <a id="11035" href="SyntheticReals.html#9975" class="Function">IsLimit</a> <a id="11043" href="SyntheticReals.html#10883" class="Bound">x</a> <a id="11045" href="SyntheticReals.html#11027" class="Bound">l</a>

  <a id="11050" class="Comment">-- For the remainder of this section, additionally assume that F is Archimedean.</a>
  <a id="11133" class="Keyword">module</a> <a id="11140" href="SyntheticReals.html#11140" class="Module">_</a> <a id="11142" class="Symbol">(</a><a id="11143" href="SyntheticReals.html#11143" class="Bound">isArchimedian</a> <a id="11157" class="Symbol">:</a> <a id="11159" href="SyntheticReals.html#5738" class="Function">IsArchimedian</a> <a id="11173" href="SyntheticReals.html#7665" class="Bound">OF</a><a id="11175" class="Symbol">)</a> <a id="11177" class="Keyword">where</a>

    <a id="11188" class="Comment">-- Lemma 4.4.5.</a>
    <a id="11208" class="Comment">-- The type of limits of a fixed sequence x : N → F is a proposition.</a>
    <a id="11282" href="SyntheticReals.html#11282" class="Function">Lemma-4-4-5</a> <a id="11294" class="Symbol">:</a> <a id="11296" class="Symbol">∀(</a><a id="11298" href="SyntheticReals.html#11298" class="Bound">x</a> <a id="11300" class="Symbol">:</a> <a id="11302" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="11304" class="Symbol">→</a> <a id="11306" href="SyntheticReals.html#7743" class="Field">F</a><a id="11307" class="Symbol">)</a> <a id="11309" class="Symbol">→</a> <a id="11311" href="Cubical.Foundations.Id.html#910" class="Function">isProp</a> <a id="11318" class="Symbol">(</a><a id="11319" href="Cubical.Core.Primitives.html#6306" class="Function">Σ[</a> <a id="11322" href="SyntheticReals.html#11322" class="Bound">l</a> <a id="11324" href="Cubical.Core.Primitives.html#6306" class="Function">∈</a> <a id="11326" href="SyntheticReals.html#7743" class="Field">F</a> <a id="11328" href="Cubical.Core.Primitives.html#6306" class="Function">]</a> <a id="11330" href="SyntheticReals.html#9975" class="Function">IsLimit</a> <a id="11338" href="SyntheticReals.html#11298" class="Bound">x</a> <a id="11340" href="SyntheticReals.html#11322" class="Bound">l</a><a id="11341" class="Symbol">)</a>
    <a id="11347" class="Comment">-- Proof. This can be shown using the usual proof that limits are unique in Archimedean ordered fields, followed by an application of Lemma 2.6.20.</a>
    <a id="11499" href="SyntheticReals.html#11282" class="Function">Lemma-4-4-5</a> <a id="11511" href="SyntheticReals.html#11511" class="Bound">x</a> <a id="11513" class="Symbol">=</a> <a id="11515" class="Symbol">{!!}</a>

    <a id="11525" class="Comment">-- Corollary 4.4.6.</a>
    <a id="11549" class="Comment">-- Fix a given sequence x : N → F . Suppose that we know that there exists a</a>
    <a id="11630" class="Comment">-- limit of the sequence. Then we can compute a limit of the sequence.</a>
    <a id="11705" href="SyntheticReals.html#11705" class="Function">Corollary-4-4-6</a> <a id="11721" class="Symbol">:</a> <a id="11723" class="Symbol">∀(</a><a id="11725" href="SyntheticReals.html#11725" class="Bound">x</a> <a id="11727" class="Symbol">:</a> <a id="11729" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="11731" class="Symbol">→</a> <a id="11733" href="SyntheticReals.html#7743" class="Field">F</a><a id="11734" class="Symbol">)</a> <a id="11736" class="Symbol">→</a> <a id="11738" class="Symbol">(</a><a id="11739" href="Cubical.Data.Sigma.Base.html#709" class="Function">∃[</a> <a id="11742" href="SyntheticReals.html#11742" class="Bound">l</a> <a id="11744" href="Cubical.Data.Sigma.Base.html#709" class="Function">∈</a> <a id="11746" href="SyntheticReals.html#7743" class="Field">F</a> <a id="11748" href="Cubical.Data.Sigma.Base.html#709" class="Function">]</a> <a id="11750" href="SyntheticReals.html#9975" class="Function">IsLimit</a> <a id="11758" href="SyntheticReals.html#11725" class="Bound">x</a> <a id="11760" href="SyntheticReals.html#11742" class="Bound">l</a><a id="11761" class="Symbol">)</a> <a id="11763" class="Symbol">→</a> <a id="11765" href="Cubical.Core.Primitives.html#6306" class="Function">Σ[</a> <a id="11768" href="SyntheticReals.html#11768" class="Bound">l</a> <a id="11770" href="Cubical.Core.Primitives.html#6306" class="Function">∈</a> <a id="11772" href="SyntheticReals.html#7743" class="Field">F</a> <a id="11774" href="Cubical.Core.Primitives.html#6306" class="Function">]</a> <a id="11776" href="SyntheticReals.html#9975" class="Function">IsLimit</a> <a id="11784" href="SyntheticReals.html#11725" class="Bound">x</a> <a id="11786" href="SyntheticReals.html#11768" class="Bound">l</a>
    <a id="11792" class="Comment">-- Proof. By applying the induction principle of propositional truncations of Definition 2.4.3.</a>
    <a id="11892" href="SyntheticReals.html#11705" class="Function">Corollary-4-4-6</a> <a id="11908" href="SyntheticReals.html#11908" class="Bound">x</a> <a id="11910" href="SyntheticReals.html#11910" class="Bound">p</a> <a id="11912" class="Symbol">=</a> <a id="11914" class="Symbol">{!!}</a> <a id="11919" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="11921" class="Symbol">{!!}</a>

    <a id="11931" class="Comment">-- Corollary 4.4.7.</a>
    <a id="11955" class="Comment">-- Fix a given sequence x : N → F . Suppose that, from a modulus of Cauchy</a>
    <a id="12034" class="Comment">-- convergence, we can compute a limit of the sequence. Then from the existence of the modulus of</a>
    <a id="12136" class="Comment">-- Cauchy convergence we can compute a limit of the sequence.</a>
    <a id="12202" href="SyntheticReals.html#12202" class="Function">Corollary-4-4-7</a> <a id="12218" class="Symbol">:</a> <a id="12220" class="Symbol">(</a><a id="12221" href="SyntheticReals.html#12221" class="Bound">x</a> <a id="12223" class="Symbol">:</a> <a id="12225" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="12227" class="Symbol">→</a> <a id="12229" href="SyntheticReals.html#7743" class="Field">F</a><a id="12230" class="Symbol">)</a>
                    <a id="12252" class="Symbol">→</a> <a id="12254" class="Symbol">(</a> <a id="12256" class="Symbol">(</a><a id="12257" href="SyntheticReals.html#12257" class="Bound">M</a> <a id="12259" class="Symbol">:</a> <a id="12261" class="Symbol">((</a><a id="12263" href="SyntheticReals.html#12263" class="Bound">y</a> <a id="12265" class="Symbol">:</a> <a id="12267" href="SyntheticReals.html#7845" class="Function">ℚ</a><a id="12268" class="Symbol">)</a> <a id="12270" class="Symbol">→</a> <a id="12272" class="Symbol">{{</a><a id="12274" href="SyntheticReals.html#7839" class="Function">0ᵣ</a> <a id="12277" href="SyntheticReals.html#7827" class="Function Operator">&lt;ᵣ</a> <a id="12280" href="SyntheticReals.html#12263" class="Bound">y</a><a id="12281" class="Symbol">}}</a> <a id="12284" class="Symbol">→</a> <a id="12286" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="12287" class="Symbol">))</a>
                      <a id="12312" class="Symbol">→</a> <a id="12314" class="Symbol">(</a><a id="12315" href="SyntheticReals.html#12315" class="Bound">isMCC</a> <a id="12321" class="Symbol">:</a> <a id="12323" href="SyntheticReals.html#9259" class="Function">IsModulusOfCauchyConvergence</a> <a id="12352" href="SyntheticReals.html#12221" class="Bound">x</a> <a id="12354" href="SyntheticReals.html#12257" class="Bound">M</a><a id="12355" class="Symbol">)</a>
                      <a id="12379" class="Symbol">→</a> <a id="12381" href="Cubical.Core.Primitives.html#6306" class="Function">Σ[</a> <a id="12384" href="SyntheticReals.html#12384" class="Bound">l</a> <a id="12386" href="Cubical.Core.Primitives.html#6306" class="Function">∈</a> <a id="12388" href="SyntheticReals.html#7743" class="Field">F</a> <a id="12390" href="Cubical.Core.Primitives.html#6306" class="Function">]</a> <a id="12392" href="SyntheticReals.html#9975" class="Function">IsLimit</a> <a id="12400" href="SyntheticReals.html#12221" class="Bound">x</a> <a id="12402" href="SyntheticReals.html#12384" class="Bound">l</a>
                      <a id="12426" class="Symbol">)</a>
                    <a id="12448" class="Comment">-----------------------------------------------------------------------</a>
                    <a id="12540" class="Symbol">→</a> <a id="12542" href="Cubical.Data.Sigma.Base.html#709" class="Function">∃[</a> <a id="12545" href="SyntheticReals.html#12545" class="Bound">M</a> <a id="12547" href="Cubical.Data.Sigma.Base.html#709" class="Function">∈</a> <a id="12549" class="Symbol">((</a><a id="12551" href="SyntheticReals.html#12551" class="Bound">y</a> <a id="12553" class="Symbol">:</a> <a id="12555" href="SyntheticReals.html#7845" class="Function">ℚ</a><a id="12556" class="Symbol">)</a> <a id="12558" class="Symbol">→</a> <a id="12560" class="Symbol">{{</a><a id="12562" href="SyntheticReals.html#7839" class="Function">0ᵣ</a> <a id="12565" href="SyntheticReals.html#7827" class="Function Operator">&lt;ᵣ</a> <a id="12568" href="SyntheticReals.html#12551" class="Bound">y</a><a id="12569" class="Symbol">}}</a> <a id="12572" class="Symbol">→</a> <a id="12574" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="12575" class="Symbol">)</a> <a id="12577" href="Cubical.Data.Sigma.Base.html#709" class="Function">]</a> <a id="12579" href="SyntheticReals.html#9259" class="Function">IsModulusOfCauchyConvergence</a> <a id="12608" href="SyntheticReals.html#12221" class="Bound">x</a> <a id="12610" href="SyntheticReals.html#12545" class="Bound">M</a>
                    <a id="12632" class="Symbol">→</a> <a id="12634" href="Cubical.Core.Primitives.html#6306" class="Function">Σ[</a> <a id="12637" href="SyntheticReals.html#12637" class="Bound">l</a> <a id="12639" href="Cubical.Core.Primitives.html#6306" class="Function">∈</a> <a id="12641" href="SyntheticReals.html#7743" class="Field">F</a> <a id="12643" href="Cubical.Core.Primitives.html#6306" class="Function">]</a> <a id="12645" href="SyntheticReals.html#9975" class="Function">IsLimit</a> <a id="12653" href="SyntheticReals.html#12221" class="Bound">x</a> <a id="12655" href="SyntheticReals.html#12637" class="Bound">l</a>
    <a id="12661" class="Comment">-- Proof. By applying the induction principle of propositional truncations of Definition 2.4.3.</a>
    <a id="12761" href="SyntheticReals.html#12202" class="Function">Corollary-4-4-7</a> <a id="12777" href="SyntheticReals.html#12777" class="Bound">x</a> <a id="12779" href="SyntheticReals.html#12779" class="Bound">f</a> <a id="12781" href="SyntheticReals.html#12781" class="Bound">p</a> <a id="12783" class="Symbol">=</a> <a id="12785" class="Symbol">{!!}</a>

    <a id="12795" class="Comment">-- We can thus compute the limit of x : N → F as the number lim(x, p), where p is a proof</a>
    <a id="12889" class="Comment">-- that the limit of x exists. We will rather use the more traditional notation lim n→∞ x n for this</a>
    <a id="12994" class="Comment">-- number.</a>

    <a id="13010" class="Comment">-- Example 4.4.8 (Exponential function).</a>
    <a id="13055" class="Comment">-- In a Cauchy complete Archimedean ordered field, we can define an exponential function exp : F → F by</a>
    <a id="13163" class="Comment">--</a>
    <a id="13170" class="Comment">--    exp(x) = Σ_{k=0}^{∞} (xᵏ) / (k!)</a>
    <a id="13213" class="Comment">--</a>
    <a id="13220" class="Comment">-- For a given input x, we obtain the existence of a modulus of Cauchy convergence for the output from boundedness of</a>
    <a id="13342" class="Comment">-- x, that is, from the fact that (∃q, r : Q) q &lt; x &lt; r .</a>

    <a id="13405" href="SyntheticReals.html#13405" class="Function">exp</a> <a id="13409" class="Symbol">:</a> <a id="13411" href="SyntheticReals.html#7743" class="Field">F</a> <a id="13413" class="Symbol">→</a> <a id="13415" href="SyntheticReals.html#7743" class="Field">F</a>
    <a id="13421" href="SyntheticReals.html#13405" class="Function">exp</a> <a id="13425" href="SyntheticReals.html#13425" class="Bound">x</a> <a id="13427" class="Symbol">=</a> <a id="13429" class="Symbol">{!!}</a>

    <a id="13439" href="SyntheticReals.html#13439" class="Function">Example-4-4-8</a> <a id="13453" class="Symbol">:</a> <a id="13455" class="Symbol">∀(</a><a id="13457" href="SyntheticReals.html#13457" class="Bound">x</a> <a id="13459" class="Symbol">:</a> <a id="13461" href="SyntheticReals.html#7743" class="Field">F</a><a id="13462" class="Symbol">)</a> <a id="13464" class="Symbol">→</a> <a id="13466" href="Cubical.Data.Sigma.Base.html#709" class="Function">∃[</a> <a id="13469" href="SyntheticReals.html#13469" class="Bound">M</a> <a id="13471" href="Cubical.Data.Sigma.Base.html#709" class="Function">∈</a> <a id="13473" class="Symbol">((</a><a id="13475" href="SyntheticReals.html#13475" class="Bound">y</a> <a id="13477" class="Symbol">:</a> <a id="13479" href="SyntheticReals.html#7845" class="Function">ℚ</a><a id="13480" class="Symbol">)</a> <a id="13482" class="Symbol">→</a> <a id="13484" class="Symbol">{{</a><a id="13486" href="SyntheticReals.html#7839" class="Function">0ᵣ</a> <a id="13489" href="SyntheticReals.html#7827" class="Function Operator">&lt;ᵣ</a> <a id="13492" href="SyntheticReals.html#13475" class="Bound">y</a><a id="13493" class="Symbol">}}</a> <a id="13496" class="Symbol">→</a> <a id="13498" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="13499" class="Symbol">)</a> <a id="13501" href="Cubical.Data.Sigma.Base.html#709" class="Function">]</a> <a id="13503" href="SyntheticReals.html#9259" class="Function">IsModulusOfCauchyConvergence</a> <a id="13532" class="Symbol">{!!}</a> <a id="13537" href="SyntheticReals.html#13469" class="Bound">M</a>
    <a id="13543" href="SyntheticReals.html#13439" class="Function">Example-4-4-8</a> <a id="13557" href="SyntheticReals.html#13557" class="Bound">x</a> <a id="13559" class="Keyword">with</a> <a id="13564" href="SyntheticReals.html#6482" class="Function">Example-4-3-6</a> <a id="13578" href="SyntheticReals.html#7665" class="Bound">OF</a> <a id="13581" href="SyntheticReals.html#11143" class="Bound">isArchimedian</a> <a id="13595" href="SyntheticReals.html#13557" class="Bound">x</a>
    <a id="13601" class="Symbol">...</a> <a id="13605" class="Symbol">|</a> <a id="13607" href="SyntheticReals.html#13607" class="Bound">q&#39;</a> <a id="13610" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="13612" href="SyntheticReals.html#13612" class="Bound">r&#39;</a> <a id="13615" class="Symbol">=</a> <a id="13617" class="Keyword">let</a> <a id="13621" href="SyntheticReals.html#13621" class="Bound">q</a> <a id="13623" class="Symbol">:</a> <a id="13625" href="Cubical.Data.Sigma.Base.html#709" class="Function">∃[</a> <a id="13628" href="SyntheticReals.html#13628" class="Bound">q</a> <a id="13630" href="Cubical.Data.Sigma.Base.html#709" class="Function">∈</a> <a id="13632" href="SyntheticReals.html#7845" class="Function">ℚ</a> <a id="13634" href="Cubical.Data.Sigma.Base.html#709" class="Function">]</a> <a id="13636" href="SyntheticReals.html#7876" class="Function">iᵣ</a> <a id="13639" href="SyntheticReals.html#13628" class="Bound">q</a> <a id="13641" href="Bundles.html#10938" class="Field Operator">&lt;</a> <a id="13643" class="Bound">x</a>
                        <a id="13669" href="SyntheticReals.html#13621" class="Bound">q</a> <a id="13671" class="Symbol">=</a> <a id="13673" href="SyntheticReals.html#13607" class="Bound">q&#39;</a>
                        <a id="13700" href="SyntheticReals.html#13700" class="Bound">r</a> <a id="13702" class="Symbol">:</a> <a id="13704" href="Cubical.Data.Sigma.Base.html#709" class="Function">∃[</a> <a id="13707" href="SyntheticReals.html#13707" class="Bound">r</a> <a id="13709" href="Cubical.Data.Sigma.Base.html#709" class="Function">∈</a> <a id="13711" href="SyntheticReals.html#7845" class="Function">ℚ</a> <a id="13713" href="Cubical.Data.Sigma.Base.html#709" class="Function">]</a> <a id="13715" class="Bound">x</a> <a id="13717" href="Bundles.html#10938" class="Field Operator">&lt;</a> <a id="13719" href="SyntheticReals.html#7876" class="Function">iᵣ</a> <a id="13722" href="SyntheticReals.html#13707" class="Bound">r</a>
                        <a id="13748" href="SyntheticReals.html#13700" class="Bound">r</a> <a id="13750" class="Symbol">=</a> <a id="13752" href="SyntheticReals.html#13612" class="Bound">r&#39;</a>
                    <a id="13775" class="Keyword">in</a> <a id="13778" class="Symbol">{!!}</a>

    <a id="13788" class="Comment">-- The point of this work is that, because we have a single language for properties and struc-</a>
    <a id="13887" class="Comment">-- ture, we can see more precisely what is needed for certain computations. In the above example,</a>
    <a id="13989" class="Comment">-- we explicitly do not require that inputs come equipped with a modulus of Cauchy convergence,</a>
    <a id="14089" class="Comment">-- but rather that there exists such a modulus. On the one hand, we do need a modulus to obtain</a>
    <a id="14189" class="Comment">-- the limit, but as the limit value is independent of the chosen modulus, existence of such a</a>
    <a id="14288" class="Comment">-- modulus suffices.</a>

    <a id="14314" class="Comment">-- Definition 4.4.9. The Cauchy reals ℝC is the collection of rational sequences equipped with</a>
    <a id="14413" class="Comment">-- a modulus of Cauchy convergence, quotiented (as in Section 2.7) by an equivalence relation</a>
    <a id="14511" class="Comment">-- that relates two sequence–modulus pairs (x, M) and (y, N ) iff</a>
    <a id="14581" class="Comment">-- (∀ε : Q + ) x M (ε/4) − y M (ε/4) &lt; ε.</a>

    <a id="14628" href="SyntheticReals.html#14628" class="Function">ℝC</a> <a id="14631" class="Symbol">:</a> <a id="14633" class="UnsolvedMeta Symbol">{!!}</a>
    <a id="14642" href="SyntheticReals.html#14628" class="Function">ℝC</a> <a id="14645" class="Symbol">=</a> <a id="14647" class="Symbol">{!!}</a>

    <a id="14657" class="Comment">-- The Cauchy reals form an Archimedean ordered field in a natural way. The natural strategy</a>
    <a id="14754" class="Comment">-- to prove that the Cauchy reals are Cauchy complete, perhaps surprisingly, does not work, and</a>
    <a id="14854" class="Comment">-- in some constructive foundations the Cauchy completeness of the Cauchy reals is known to</a>
    <a id="14950" class="Comment">-- be false [68].</a>
    <a id="14972" class="Comment">-- </a>
    <a id="14980" class="Comment">-- ...</a>
    <a id="14991" class="Comment">-- </a>
    <a id="14999" class="Comment">-- An alternative interpretation of the non-completeness of the Cauchy reals is that the sequential</a>
    <a id="15103" class="Comment">-- definition of completeness ought to be amended [80].</a>
    
    <a id="15168" class="Comment">-- NOTE: now we&#39;re back to https://github.com/agda/cubical/issues/286 ?</a>


<a id="15242" class="Comment">-- Auke would send an email to Ayberk Tosun and Martin Escardo</a>
<a id="15305" class="Comment">-- I could prepare a PR for the cubical standard library</a>
<a id="15362" class="Comment">-- the cubical standard library does not supersede the standard library</a>
<a id="15434" class="Comment">--   using setoids need not to be a shortcoming but can be a concious decision</a>
<a id="15513" class="Comment">-- Postulating the rationals as an ordered field for which there exists a unique morphism to every other ordered field should be sufficient</a>
<a id="15653" class="Comment">--   (we went a little bit into the coprime and quotient construction of the rational numbers)</a>
<a id="15748" class="Comment">-- I can prepare some statements that I would like to formalize (with just guessing) to have a more concrete guidance for the necessary detail of a real number formulation</a>
<a id="15920" class="Comment">-- the impredicative `--prop` is not equivalent to hProp</a>
<a id="15977" class="Comment">--   therefore, one should make props explicit arguments or at least be aware of them at all times</a>


<a id="16078" class="Comment">{-

in a world where we &quot;just have&quot; real numbers in Agda, I would do the following:

Adjoint theory
  Vector space
  normed space
  Banach space
  Inner Product space
  unbounded Linear operator
  adjoint linear operator
  orthogonal decomposition of Banach spaces
  inf-sup conditions
  lax-milgram

Local Multilinear Algebra
  euclidean space
  linear representation of hodge star
  locally euclidean

Global Multilinear Algebra
  locally euclidean topological space
  chart representation


-}</a>
</pre></body></html>