<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Number</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Symbol">{-#</a> <a id="5" class="Keyword">OPTIONS</a> <a id="13" class="Pragma">--cubical</a> <a id="23" class="Pragma">--no-import-sorts</a> <a id="41" class="Pragma">--allow-unsolved-metas</a> <a id="64" class="Symbol">#-}</a>

<a id="69" class="Keyword">module</a> <a id="76" href="Number.html" class="Module">Number</a> <a id="83" class="Keyword">where</a>

<a id="90" class="Keyword">open</a> <a id="95" class="Keyword">import</a> <a id="102" href="Agda.Primitive.html" class="Module">Agda.Primitive</a> <a id="117" class="Keyword">renaming</a> <a id="126" class="Symbol">(</a><a id="127" href="Agda.Primitive.html#736" class="Primitive Operator">_⊔_</a> <a id="131" class="Symbol">to</a> <a id="Primitive._⊔_"></a><a id="134" href="Number.html#134" class="Primitive Operator">ℓ-max</a><a id="139" class="Symbol">;</a> <a id="141" href="Agda.Primitive.html#706" class="Primitive">lsuc</a> <a id="146" class="Symbol">to</a> <a id="Primitive.lsuc"></a><a id="149" href="Number.html#149" class="Primitive">ℓ-suc</a><a id="154" class="Symbol">;</a> <a id="156" href="Agda.Primitive.html#690" class="Primitive">lzero</a> <a id="162" class="Symbol">to</a> <a id="Primitive.lzero"></a><a id="165" href="Number.html#165" class="Primitive">ℓ-zero</a><a id="171" class="Symbol">)</a>

<a id="174" class="Keyword">private</a>
  <a id="184" class="Keyword">variable</a>
    <a id="197" href="Number.html#197" class="Generalizable">ℓ</a> <a id="199" href="Number.html#199" class="Generalizable">ℓ&#39;</a> <a id="202" href="Number.html#202" class="Generalizable">ℓ&#39;&#39;</a> <a id="206" class="Symbol">:</a> <a id="208" href="Agda.Primitive.html#523" class="Postulate">Level</a>

<a id="215" class="Keyword">open</a> <a id="220" class="Keyword">import</a> <a id="227" href="Cubical.Foundations.Everything.html" class="Module">Cubical.Foundations.Everything</a> <a id="258" class="Keyword">renaming</a> <a id="267" class="Symbol">(</a><a id="268" href="Cubical.Foundations.GroupoidLaws.html#311" class="Function Operator">_⁻¹</a> <a id="272" class="Symbol">to</a> <a id="Foundations.GroupoidLaws._⁻¹"></a><a id="275" href="Number.html#275" class="Function Operator">_⁻¹ᵖ</a><a id="279" class="Symbol">;</a> <a id="281" href="Cubical.Foundations.GroupoidLaws.html#2243" class="Function">assoc</a> <a id="287" class="Symbol">to</a> <a id="Foundations.GroupoidLaws.assoc"></a><a id="290" href="Number.html#290" class="Function">∙-assoc</a><a id="297" class="Symbol">)</a>
<a id="299" class="Keyword">open</a> <a id="304" class="Keyword">import</a> <a id="311" href="Cubical.Relation.Nullary.Base.html" class="Module">Cubical.Relation.Nullary.Base</a> <a id="341" class="Comment">-- ¬_</a>
<a id="347" class="Keyword">open</a> <a id="352" class="Keyword">import</a> <a id="359" href="Cubical.Relation.Binary.Base.html" class="Module">Cubical.Relation.Binary.Base</a> <a id="388" class="Comment">-- Rel</a>
<a id="395" class="Keyword">open</a> <a id="400" class="Keyword">import</a> <a id="407" href="Cubical.Data.Unit.Base.html" class="Module">Cubical.Data.Unit.Base</a> <a id="430" class="Comment">-- Unit</a>
<a id="438" class="Keyword">open</a> <a id="443" class="Keyword">import</a> <a id="450" href="Cubical.Data.Empty.html" class="Module">Cubical.Data.Empty</a> <a id="469" class="Comment">-- ⊥</a>
<a id="474" class="Keyword">open</a> <a id="479" class="Keyword">import</a> <a id="486" href="Cubical.Data.Sum.Base.html" class="Module">Cubical.Data.Sum.Base</a> <a id="508" class="Keyword">renaming</a> <a id="517" class="Symbol">(</a><a id="518" href="Cubical.Data.Sum.Base.html#188" class="Datatype Operator">_⊎_</a> <a id="522" class="Symbol">to</a> <a id="525" class="Keyword">infixr</a> <a id="532" class="Number">4</a> <a id="Data.Sum.Base._⊎_"></a><a id="534" href="Number.html#534" class="Datatype Operator">_⊎_</a><a id="537" class="Symbol">)</a>
<a id="539" class="Keyword">open</a> <a id="544" class="Keyword">import</a> <a id="551" href="Cubical.Data.Sigma.Base.html" class="Module">Cubical.Data.Sigma.Base</a> <a id="575" class="Keyword">renaming</a> <a id="584" class="Symbol">(</a><a id="585" href="Cubical.Data.Sigma.Base.html#489" class="Function Operator">_×_</a> <a id="589" class="Symbol">to</a> <a id="592" class="Keyword">infixr</a> <a id="599" class="Number">4</a> <a id="Data.Sigma.Base._×_"></a><a id="601" href="Number.html#601" class="Function Operator">_×_</a><a id="604" class="Symbol">)</a>
<a id="606" class="Keyword">open</a> <a id="611" class="Keyword">import</a> <a id="618" href="Cubical.Data.Empty.html" class="Module">Cubical.Data.Empty</a> <a id="637" class="Keyword">renaming</a> <a id="646" class="Symbol">(</a><a id="647" href="Cubical.Data.Empty.Base.html#190" class="Function">elim</a> <a id="652" class="Symbol">to</a> <a id="Data.Empty.Base.elim"></a><a id="655" href="Number.html#655" class="Function">⊥-elim</a><a id="661" class="Symbol">)</a> <a id="663" class="Comment">-- `⊥` and `elim`</a>
<a id="681" class="Keyword">open</a> <a id="686" class="Keyword">import</a> <a id="693" href="Function.Base.html" class="Module">Function.Base</a> <a id="707" class="Keyword">using</a> <a id="713" class="Symbol">(</a><a id="714" href="Function.Base.html#4708" class="Function">it</a><a id="716" class="Symbol">;</a> <a id="718" href="Function.Base.html#4458" class="Function Operator">_∋_</a><a id="721" class="Symbol">;</a> <a id="723" href="Function.Base.html#1577" class="Function Operator">_$_</a><a id="726" class="Symbol">)</a>

<a id="729" class="Comment">-- open import Data.Nat.Base using (ℕ) renaming (_≤_ to _≤ₙ_)</a>
<a id="791" class="Comment">-- open import Cubical.Data.Nat using (ℕ; zero; suc) renaming (_+_ to _+ₙ_)</a>
<a id="867" class="Comment">-- open import Cubical.Data.Nat.Order renaming (zero-≤ to z≤n; suc-≤-suc to s≤s; _≤_ to _≤ₙ_; _&lt;_ to _&lt;ₙ_)</a>
<a id="974" class="Comment">-- open import Cubical.Data.Fin.Base</a>
<a id="1011" class="Comment">-- import Cubical.Data.Fin.Properties</a>
<a id="1049" class="Comment">-- open import Cubical.Data.Nat using (ℕ; zero; suc) renaming (_+_ to _+ₙ_)</a>
<a id="1125" class="Comment">-- open import Cubical.Data.Nat.Properties using (+-suc; injSuc; snotz; +-comm; +-assoc; +-zero; inj-m+)</a>
<a id="1230" class="Comment">-- open import Cubical.Data.Nat.Order renaming (zero-≤ to z≤n; suc-≤-suc to s≤s; _≤_ to _≤ₙ_; _&lt;_ to _&lt;ₙ_; _≟_ to _≟ₙ_)</a>
<a id="1350" class="Comment">-- open import Data.Nat.Base using (ℕ; z≤n; s≤s; zero; suc) renaming (_≤_ to _≤ₙ_; _&lt;_ to _&lt;ₙ_; _+_ to _+ₙ_)</a>
<a id="1459" class="Comment">-- open import Agda.Builtin.Bool renaming (true to TT; false to FF)</a>
<a id="1527" class="Comment">-- import Cubical.Data.Fin.Properties</a>
<a id="1565" class="Comment">-- open import Data.Nat.Properties using (+-mono-&lt;)</a>

<a id="1618" class="Comment">-- open import Bundles</a>

<a id="1642" class="Keyword">open</a> <a id="1647" class="Keyword">import</a> <a id="1654" href="Number.Postulates.html" class="Module">Number.Postulates</a>
<a id="1672" class="Keyword">open</a> <a id="1677" class="Keyword">import</a> <a id="1684" href="Number.Structures.html" class="Module">Number.Structures</a>
<a id="1702" class="Keyword">open</a> <a id="1707" class="Keyword">import</a> <a id="1714" href="Number.Bundles.html" class="Module">Number.Bundles</a>
<a id="1729" class="Keyword">open</a> <a id="1734" class="Keyword">import</a> <a id="1741" href="Number.Inclusions.html" class="Module">Number.Inclusions</a>
<a id="1759" class="Keyword">open</a> <a id="1764" class="Keyword">import</a> <a id="1771" href="Number.Base.html" class="Module">Number.Base</a>
<a id="1783" class="Keyword">open</a> <a id="1788" class="Keyword">import</a> <a id="1795" href="Number.Coercions.html" class="Module">Number.Coercions</a>
<a id="1812" class="Keyword">open</a> <a id="1817" class="Keyword">import</a> <a id="1824" href="Number.Operations.html" class="Module">Number.Operations</a>

<a id="1843" class="Keyword">open</a> <a id="1848" href="Number.Postulates.html#2235" class="Module">ℕⁿ</a>
<a id="1851" class="Keyword">open</a> <a id="1856" href="Number.Postulates.html#3568" class="Module">ℤᶻ</a>
<a id="1859" class="Keyword">open</a> <a id="1864" href="Number.Postulates.html#4946" class="Module">ℚᶠ</a>
<a id="1867" class="Keyword">open</a> <a id="1872" href="Number.Postulates.html#6734" class="Module">ℝʳ</a>
<a id="1875" class="Keyword">open</a> <a id="1880" href="Number.Postulates.html#8167" class="Module">ℂᶜ</a>

<a id="1884" class="Keyword">import</a> <a id="1891" href="Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a>


<a id="1913" class="Comment">-- NOTE: well, for 15 allowed coercions, we might just enumerate them</a>
<a id="1983" class="Comment">--   unfortunately with overlapping patterns a style as in `Cl` is not possible</a>
<a id="2063" class="Comment">--   we need to explicitly write out all the 5×5 combinations</a>
<a id="2125" class="Comment">--   or, we implement a min operator which might work even with overlapping patterns</a>

<a id="2211" class="Comment">-- num {isNat     ,, p} (x ,, q) = x</a>
<a id="2248" class="Comment">-- num {isInt     ,, p} (x ,, q) = x</a>
<a id="2285" class="Comment">-- num {isRat     ,, p} (x ,, q) = x</a>
<a id="2322" class="Comment">-- num {isReal    ,, p} (x ,, q) = x</a>
<a id="2359" class="Comment">-- num {isComplex ,, p} (x ,, q) = x</a>


<a id="2398" class="Comment">-- TODO: name this &quot;inject&quot; instead of &quot;coerce&quot;</a>
<a id="2446" class="Comment">-- TODO: make the module ℤ and the Carrier ℤ.ℤ</a>
<a id="2493" class="Comment">-- TODO: for a binary relation `a # b` it would be nice to have a way to compose ≡-pathes to the left and the right</a>
<a id="2609" class="Comment">--       similar to how ∙ can be used for pathes</a>
<a id="2658" class="Comment">--       this reasoning might extend to transitive relations</a>
<a id="2719" class="Comment">--       `cong₂ _#_ refl x` and `cong₂ _#_ x refl` to this (together with `transport`)</a>
<a id="2806" class="Comment">-- NOTE: maybe ℕ↪ℤ should be a postfix operation</a>

<a id="2856" class="Comment">-- module _ where</a>
<a id="2874" class="Comment">-- module ℕ&#39; = ROrderedCommSemiring ℕ.Bundle</a>
<a id="2919" class="Comment">-- module ℤ&#39; = ROrderedCommRing     ℤ.Bundle</a>
<a id="2964" class="Comment">-- module ℚ&#39; = ROrderedField        ℚ.Bundle</a>
<a id="3009" class="Comment">-- module ℝ&#39; = ROrderedField        ℝ.Bundle</a>
<a id="3054" class="Comment">-- module ℂ&#39; = RField               ℂ.Bundle-- </a>

  

<a id="3107" class="Comment">-- coerce-OCSR : ∀{l p} {ll : NumberKind} {𝕏OCSR 𝕐OCSR : ROrderedCommSemiring {ℝℓ} {ℝℓ&#39;}}</a>
<a id="3197" class="Comment">--             → (x : Number (l ,, p))</a>
<a id="3236" class="Comment">--             → {f : Il l → Il ll}</a>
<a id="3272" class="Comment">--             → IsROrderedCommSemiringInclusion 𝕏OCSR 𝕐OCSR f</a>
<a id="3335" class="Comment">--             → Ip ll p (f (num x))</a>
<a id="3372" class="Comment">-- coerce-OCSR {l} {ll} {p} {𝕏OCSR} {𝕐OCSR} {f} (x ,, q) = ?</a>

<a id="3434" class="Comment">{-
private
  instance
    z≤n&#39; : ∀ {n}                 → zero  ≤ₙ n
    z≤n&#39; {n} = z≤n
    s≤s&#39; : ∀ {m n} {{m≤n : m ≤ₙ n}} → suc m ≤ₙ suc n
    s≤s&#39; {m} {n} {{m≤n}} = s≤s m≤n
-}</a>

<a id="3613" class="Comment">{-
-- TODO: why does `it` not work here?
⁻¹-Levels : (a : NumberKind) → Σ[ b ∈ NumberKind ] a ≤ₙₗ b
⁻¹-Levels isNat     = isRat     , z≤n -- it
⁻¹-Levels isInt     = isRat     , s≤s z≤n -- s≤s&#39; {{z≤n&#39;}}
⁻¹-Levels isRat     = isRat     , s≤s (s≤s z≤n) 
⁻¹-Levels isReal    = isReal    , s≤s (s≤s (s≤s z≤n)) -- it 
⁻¹-Levels isComplex = isComplex , s≤s (s≤s (s≤s (s≤s z≤n))) 

⁻¹-Levels&#39; : (a : NumberKind) → NumberKind
⁻¹-Levels&#39; x = maxₙₗ x isRat
-}</a>

<a id="4064" class="Keyword">open</a> <a id="4069" href="Number.Base.html#2233" class="Module">PatternsType</a>

<a id="4083" class="Comment">{-
private
  pattern X   = anyPositivity
  pattern X⁺⁻ = isNonzero
  pattern X₀⁺ = isNonnegative
  pattern X⁺  = isPositive
  pattern X⁻  = isNegative
  pattern X₀⁻ = isNonpositive
-}</a>

<a id="4268" class="Comment">{-
⁻¹-Types : NumberProp → Maybe NumberProp
⁻¹-Types (level ,, X  ) = nothing
⁻¹-Types (level ,, X₀⁺) = nothing
⁻¹-Types (level ,, X₀⁻) = nothing
⁻¹-Types (level ,, p  ) = just (fst (⁻¹-Levels level) ,, p)
-}</a>

<a id="4478" class="Comment">-- ∀{{ q : Unit }} → Number (level ,, X⁺⁻)</a>
<a id="4521" class="Comment">-- ∀{{ q : Unit }} → Number (level ,, X⁺ )</a>
<a id="4564" class="Comment">-- ∀{{ q : Unit }} → Number (level ,, X⁻ )</a>

<a id="4608" class="Comment">-- pattern [ℝ₀⁺] = (isReal , X₀⁺)</a>
<a id="4642" class="Comment">-- [ℝ₀⁺] = Number (isReal , isNonnegativeᵒʳ)</a>
<a id="4687" class="Comment">-- [ℝ⁺]  = Number (isReal , isPositiveᵒʳ)</a>
<a id="4729" class="Comment">-- [ℕ⁺]  = Number (isNat  , isPositiveᵒʳ)</a>
<a id="4771" class="Comment">-- [ℝ]   = Number (isReal , anyPositivityᵒʳ)</a>

<a id="4817" class="Keyword">open</a> <a id="4822" class="Keyword">import</a> <a id="4829" href="Number.Prettyprint.html" class="Module">Number.Prettyprint</a>

<a id="4849" class="Comment">-- {-# DISPLAY maxₙₗ&#39; isReal isReal = isReal #-}</a>
<a id="4898" class="Comment">-- {-# DISPLAY Number (isReal , isNonnegative) = [ℝ₀⁺] #-}</a>
<a id="4957" class="Comment">-- {-# DISPLAY Number (isReal , isPositive)    = [ℝ⁺]  #-}</a>


<a id="[1ʳ]"></a><a id="5018" href="Number.html#5018" class="Function">[1ʳ]</a> <a id="5023" class="Symbol">:</a> <a id="5025" href="Number.Prettyprint.html#1070" class="Function">[ℝ⁺]</a>
<a id="5030" href="Number.html#5018" class="Function">[1ʳ]</a> <a id="5035" class="Symbol">=</a> <a id="5037" href="Number.Postulates.html#6900" class="Function">1ʳ</a> <a id="5040" href="Number.Base.html#7738" class="InductiveConstructor Operator">,,</a> <a id="5043" href="Number.Structures.html#3521" class="Function">ℝ.0&lt;1</a>

<a id="[1]-Type"></a><a id="5050" href="Number.html#5050" class="Function">[1]-Type</a> <a id="5059" class="Symbol">:</a> <a id="5061" class="Symbol">(</a><a id="5062" href="Number.html#5062" class="Bound">l</a> <a id="5064" class="Symbol">:</a> <a id="5066" href="Number.Base.html#497" class="Datatype">NumberKind</a><a id="5076" class="Symbol">)</a> <a id="5078" class="Symbol">→</a> <a id="5080" href="Agda.Primitive.html#326" class="Primitive">Type</a> <a id="5085" class="Symbol">(</a><a id="5086" href="Number.Base.html#7322" class="Function">NumberLevel</a> <a id="5098" href="Number.html#5062" class="Bound">l</a><a id="5099" class="Symbol">)</a>
<a id="5101" href="Number.html#5050" class="Function">[1]-Type</a> <a id="5110" href="Number.Base.html#523" class="InductiveConstructor">isNat</a>     <a id="5120" class="Symbol">=</a> <a id="5122" href="Number.Prettyprint.html#305" class="Function">[ℕ⁺]</a>
<a id="5127" href="Number.html#5050" class="Function">[1]-Type</a> <a id="5136" href="Number.Base.html#548" class="InductiveConstructor">isInt</a>     <a id="5146" class="Symbol">=</a> <a id="5148" href="Number.Prettyprint.html#530" class="Function">[ℤ⁺]</a>
<a id="5153" href="Number.html#5050" class="Function">[1]-Type</a> <a id="5162" href="Number.Base.html#573" class="InductiveConstructor">isRat</a>     <a id="5172" class="Symbol">=</a> <a id="5174" href="Number.Prettyprint.html#800" class="Function">[ℚ⁺]</a>
<a id="5179" href="Number.html#5050" class="Function">[1]-Type</a> <a id="5188" href="Number.Base.html#598" class="InductiveConstructor">isReal</a>    <a id="5198" class="Symbol">=</a> <a id="5200" href="Number.Prettyprint.html#1070" class="Function">[ℝ⁺]</a>
<a id="5205" href="Number.html#5050" class="Function">[1]-Type</a> <a id="5214" href="Number.Base.html#623" class="InductiveConstructor">isComplex</a> <a id="5224" class="Symbol">=</a> <a id="5226" href="Number.Prettyprint.html#1250" class="Function">[ℂ⁺⁻]</a>

<a id="5233" class="Comment">-- NOTE: this is ambiguous with generic operations such as _+_</a>
<a id="[1]"></a><a id="5296" href="Number.html#5296" class="Function">[1]</a> <a id="5300" class="Symbol">:</a> <a id="5302" class="Symbol">∀{</a><a id="5304" href="Number.html#5304" class="Bound">l</a><a id="5305" class="Symbol">}</a> <a id="5307" class="Symbol">→</a> <a id="5309" href="Number.html#5050" class="Function">[1]-Type</a> <a id="5318" href="Number.html#5304" class="Bound">l</a>
<a id="5320" href="Number.html#5296" class="Function">[1]</a> <a id="5324" class="Symbol">{</a><a id="5325" href="Number.Base.html#523" class="InductiveConstructor">isNat</a><a id="5330" class="Symbol">}</a>     <a id="5336" class="Symbol">=</a> <a id="5338" href="Number.Postulates.html#2402" class="Function">1ⁿ</a> <a id="5341" href="Number.Base.html#7738" class="InductiveConstructor Operator">,,</a> <a id="5344" href="Number.Structures.html#3521" class="Function">ℕ.0&lt;1</a> 
<a id="5351" href="Number.html#5296" class="Function">[1]</a> <a id="5355" class="Symbol">{</a><a id="5356" href="Number.Base.html#548" class="InductiveConstructor">isInt</a><a id="5361" class="Symbol">}</a>     <a id="5367" class="Symbol">=</a> <a id="5369" href="Number.Postulates.html#3734" class="Function">1ᶻ</a> <a id="5372" href="Number.Base.html#7738" class="InductiveConstructor Operator">,,</a> <a id="5375" href="Number.Structures.html#3521" class="Function">ℤ.0&lt;1</a> 
<a id="5382" href="Number.html#5296" class="Function">[1]</a> <a id="5386" class="Symbol">{</a><a id="5387" href="Number.Base.html#573" class="InductiveConstructor">isRat</a><a id="5392" class="Symbol">}</a>     <a id="5398" class="Symbol">=</a> <a id="5400" href="Number.Postulates.html#5094" class="Function">1ᶠ</a> <a id="5403" href="Number.Base.html#7738" class="InductiveConstructor Operator">,,</a> <a id="5406" href="Number.Structures.html#3521" class="Function">ℚ.0&lt;1</a> 
<a id="5413" href="Number.html#5296" class="Function">[1]</a> <a id="5417" class="Symbol">{</a><a id="5418" href="Number.Base.html#598" class="InductiveConstructor">isReal</a><a id="5424" class="Symbol">}</a>    <a id="5429" class="Symbol">=</a> <a id="5431" href="Number.Postulates.html#6900" class="Function">1ʳ</a> <a id="5434" href="Number.Base.html#7738" class="InductiveConstructor Operator">,,</a> <a id="5437" href="Number.Structures.html#3521" class="Function">ℝ.0&lt;1</a> 
<a id="5444" href="Number.html#5296" class="Function">[1]</a> <a id="5448" class="Symbol">{</a><a id="5449" href="Number.Base.html#623" class="InductiveConstructor">isComplex</a><a id="5458" class="Symbol">}</a> <a id="5460" class="Symbol">=</a> <a id="5462" href="Number.Postulates.html#8261" class="Function">1ᶜ</a> <a id="5465" href="Number.Base.html#7738" class="InductiveConstructor Operator">,,</a> <a id="5468" href="Number.Structures.html#2365" class="Function">ℂ.1#0</a> 


<a id="5477" class="Comment">-- test101 : Number (isNat , isPositiveᵒʳ) → Number (isReal ,  isNonnegativeᵒʳ) → {!!}</a>

<a id="5565" class="Keyword">open</a> <a id="5570" class="Keyword">import</a> <a id="5577" href="Function.Base.html" class="Module">Function.Base</a> <a id="5591" class="Keyword">using</a> <a id="5597" class="Symbol">(</a><a id="5598" href="Function.Base.html#4590" class="Function">typeOf</a><a id="5604" class="Symbol">)</a>

<a id="test201"></a><a id="5607" href="Number.html#5607" class="Function">test201</a> <a id="5615" class="Symbol">:</a> <a id="5617" href="Number.Prettyprint.html#305" class="Function">[ℕ⁺]</a> <a id="5622" class="Symbol">→</a> <a id="5624" href="Number.Prettyprint.html#1025" class="Function">[ℝ₀⁺]</a> <a id="5630" class="Symbol">→</a> <a id="5632" href="Number.Prettyprint.html#935" class="Function">[ℝ]</a>
<a id="5636" class="Comment">-- As-patterns (or @-patterns) go well with resolving things in our approach</a>
<a id="5713" href="Number.html#5607" class="Function">test201</a> <a id="5721" href="Number.html#5721" class="Bound">n</a><a id="5722" class="Symbol">@(</a><a id="5724" href="Number.html#5724" class="Bound">nn</a> <a id="5727" href="Number.Base.html#7738" class="InductiveConstructor Operator">,,</a> <a id="5730" href="Number.html#5730" class="Bound">np</a><a id="5732" class="Symbol">)</a> <a id="5734" href="Number.html#5734" class="Bound">r</a><a id="5735" class="Symbol">@(</a><a id="5737" href="Number.html#5737" class="Bound">rn</a> <a id="5740" href="Number.Base.html#7738" class="InductiveConstructor Operator">,,</a> <a id="5743" href="Number.html#5743" class="Bound">rp</a><a id="5745" class="Symbol">)</a> <a id="5747" class="Symbol">=</a> <a id="5749" class="Keyword">let</a>
<a id="5753" class="Comment">-- generic operations are provided</a>
<a id="5788" class="Comment">-- q : [ℕ⁺]</a>
<a id="5800" class="Comment">-- z : [ℝ₀⁺]</a>
   <a id="5816" href="Number.html#5816" class="Bound">q</a> <a id="5818" class="Symbol">=</a> <a id="5820" href="Number.html#5721" class="Bound">n</a> <a id="5822" href="Number.Operations.html#3098" class="Function Operator">+</a> <a id="5824" href="Number.html#5721" class="Bound">n</a>
   <a id="5829" href="Number.html#5829" class="Bound">z</a> <a id="5831" class="Symbol">=</a> <a id="5833" href="Number.html#5734" class="Bound">r</a> <a id="5835" href="Number.Operations.html#3098" class="Function Operator">+</a> <a id="5837" href="Number.html#5734" class="Bound">r</a>

<a id="5840" class="Comment">-- we can project-out the underlying number of a `Number` with `num`</a>
<a id="5909" class="Comment">-- zʳ : ℝ</a>
   <a id="5922" href="Number.html#5922" class="Bound">zʳ</a> <a id="5925" class="Symbol">=</a> <a id="5927" href="Number.Base.html#7862" class="Function">num</a> <a id="5931" href="Number.html#5829" class="Bound">z</a>

<a id="5934" class="Comment">-- and we can project-out the property of a `Number` with `prp`</a>
<a id="5998" class="Comment">-- zp : 0ʳ ≤ʳ (rn +ʳ rn)</a>
   <a id="6026" href="Number.html#6026" class="Bound">zp</a> <a id="6029" class="Symbol">=</a> <a id="6031" href="Number.Base.html#7956" class="Function">prp</a> <a id="6035" href="Number.html#5829" class="Bound">z</a>

<a id="6038" class="Comment">-- since the generic `_+_` makes use of `_+ʳ_` on ℝ, we get definitional equality</a>
   <a id="6123" href="Number.html#6123" class="Bound">_</a> <a id="6125" class="Symbol">:</a> <a id="6127" href="Number.html#5922" class="Bound">zʳ</a> <a id="6130" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="6132" href="Number.html#5737" class="Bound">rn</a> <a id="6135" href="Number.Postulates.html#6916" class="Function Operator">+ʳ</a> <a id="6138" href="Number.html#5737" class="Bound">rn</a>
   <a id="6144" class="Symbol">_</a> <a id="6146" class="Symbol">=</a> <a id="6148" href="Cubical.Foundations.Id.html#588" class="Function">refl</a>

<a id="6154" class="Comment">-- we can turn a generic number into a Σ pair with `pop`</a>
<a id="6211" class="Comment">-- qʳ   : ℕ₀</a>
<a id="6224" class="Comment">-- qʳ   = nn +ⁿ nn</a>
<a id="6243" class="Comment">-- qp   : 0ⁿ &lt;ⁿ (nn +ⁿ nn)</a>
<a id="6270" class="Comment">-- qp   = +-&lt;-&lt;-implies-&lt;ʳ nn nn np np</a>
   <a id="6312" class="Symbol">(</a><a id="6313" href="Number.html#6313" class="Bound">qʳ</a> <a id="6316" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="6318" href="Number.html#6318" class="Bound">qp</a><a id="6320" class="Symbol">)</a> <a id="6322" class="Symbol">=</a> <a id="6324" href="Number.Base.html#8068" class="Function">pop</a> <a id="6328" href="Number.html#5816" class="Bound">q</a>

<a id="6331" class="Comment">-- and we can create a number with `_,,_`</a>
<a id="6373" class="Comment">-- this needs some type annotation for help</a>
   <a id="6420" href="Number.html#6420" class="Bound">q&#39;</a> <a id="6423" class="Symbol">:</a> <a id="6425" href="Function.Base.html#4590" class="Function">typeOf</a> <a id="6432" href="Number.html#5816" class="Bound">q</a>
   <a id="6437" href="Number.html#6420" class="Bound">q&#39;</a> <a id="6440" class="Symbol">=</a> <a id="6442" href="Number.html#6313" class="Bound">qʳ</a> <a id="6445" href="Number.Base.html#7738" class="InductiveConstructor Operator">,,</a> <a id="6448" href="Number.html#6318" class="Bound">qp</a>

<a id="6452" class="Comment">-- if the two parts of q and q&#39; are in scope, then we get definitional equality</a>
   <a id="6535" href="Number.html#6535" class="Bound">_</a> <a id="6537" class="Symbol">:</a> <a id="6539" href="Number.html#5816" class="Bound">q</a> <a id="6541" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="6543" href="Number.html#6420" class="Bound">q&#39;</a>
   <a id="6549" class="Symbol">_</a> <a id="6551" class="Symbol">=</a> <a id="6553" href="Cubical.Foundations.Id.html#588" class="Function">refl</a>

<a id="6559" class="Comment">-- r is nonnegative from [ℝ₀⁺], [1ʳ] is positive from [ℝ⁺]</a>
<a id="6618" class="Comment">-- and _+_ makes use of the fact that &quot;positive + nonnegative = positive&quot;</a>
<a id="6692" class="Comment">-- y : [ℝ⁺]</a>
<a id="6704" class="Comment">-- y = (rn +ʳ 1ʳ) ,, +-≤-&lt;-implies-&lt;ʳ rn 1ʳ rp 0&lt;1</a>
   <a id="6758" href="Number.html#6758" class="Bound">y</a> <a id="6760" class="Symbol">=</a>  <a id="6763" href="Number.html#5734" class="Bound">r</a> <a id="6765" href="Number.Operations.html#3098" class="Function Operator">+</a> <a id="6767" href="Number.html#5018" class="Function">[1ʳ]</a>

<a id="6773" class="Comment">-- _+_ automatically coerces n from ℕ⁺ to ℝ⁺</a>
<a id="6818" class="Comment">-- and uses the fact that &quot;positive + nonnegative = positive&quot;</a>
<a id="6880" class="Comment">-- n+r : [ℝ⁺]</a>
<a id="6894" class="Comment">-- n+r = (ℕ↪ℝ nn +ʳ rn) ,, +-&lt;-≤-implies-&lt;ʳ (ℕ↪ℝ nn) rn (coerce-ℕ↪ℝ (nn ,, np)) rp</a>
   <a id="6980" href="Number.html#6980" class="Bound">n+r</a> <a id="6984" class="Symbol">=</a> <a id="6986" href="Number.html#5721" class="Bound">n</a> <a id="6988" href="Number.Operations.html#3098" class="Function Operator">+</a> <a id="6990" href="Number.html#5734" class="Bound">r</a>

<a id="6993" class="Comment">-- generic relations like _&lt;_ also make use of their underlying relations</a>
<a id="7067" class="Comment">-- and therefore we also get definitional equality, no matter how the relation is stated</a>
   <a id="7159" href="Number.html#7159" class="Bound">pp</a>   <a id="7164" class="Symbol">:</a> <a id="7166" href="Number.html#5018" class="Function">[1ʳ]</a> <a id="7171" href="Number.Operations.html#3781" class="Function Operator">&lt;</a>      <a id="7178" class="Symbol">(</a><a id="7179" href="Number.html#5734" class="Bound">r</a>  <a id="7182" href="Number.Operations.html#3098" class="Function Operator">+</a> <a id="7184" href="Number.html#5018" class="Function">[1ʳ]</a><a id="7188" class="Symbol">)</a>
   <a id="7193" href="Number.html#7159" class="Bound">pp</a>   <a id="7198" class="Symbol">=</a> <a id="7200" class="Symbol">{!!}</a>
   <a id="7208" href="Number.html#7208" class="Bound">pp&#39;</a>  <a id="7213" class="Symbol">:</a>  <a id="7216" href="Number.Postulates.html#6900" class="Function">1ʳ</a>  <a id="7220" href="Number.Postulates.html#6794" class="Function Operator">&lt;ʳ</a> <a id="7223" href="Number.Base.html#7862" class="Function">num</a> <a id="7227" class="Symbol">(</a><a id="7228" href="Number.html#5734" class="Bound">r</a>  <a id="7231" href="Number.Operations.html#3098" class="Function Operator">+</a> <a id="7233" href="Number.html#5018" class="Function">[1ʳ]</a><a id="7237" class="Symbol">)</a>
   <a id="7242" href="Number.html#7208" class="Bound">pp&#39;</a>  <a id="7247" class="Symbol">=</a> <a id="7249" class="Symbol">{!!}</a>
   <a id="7257" href="Number.html#7257" class="Bound">pp&#39;&#39;</a> <a id="7262" class="Symbol">:</a>  <a id="7265" href="Number.Postulates.html#6900" class="Function">1ʳ</a>  <a id="7269" href="Number.Postulates.html#6794" class="Function Operator">&lt;ʳ</a>     <a id="7276" class="Symbol">(</a><a id="7277" href="Number.html#5737" class="Bound">rn</a> <a id="7280" href="Number.Postulates.html#6916" class="Function Operator">+ʳ</a> <a id="7283" href="Number.Postulates.html#6900" class="Function">1ʳ</a> <a id="7286" class="Symbol">)</a>
   <a id="7291" href="Number.html#7257" class="Bound">pp&#39;&#39;</a> <a id="7296" class="Symbol">=</a> <a id="7298" class="Symbol">{!!}</a>
   <a id="7306" href="Number.html#7306" class="Bound">_</a> <a id="7308" class="Symbol">:</a> <a id="7310" class="Symbol">(</a><a id="7311" href="Number.html#7159" class="Bound">pp</a> <a id="7314" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="7316" href="Number.html#7208" class="Bound">pp&#39;</a><a id="7319" class="Symbol">)</a> <a id="7321" href="Number.html#601" class="Function Operator">×</a> <a id="7323" class="Symbol">(</a><a id="7324" href="Number.html#7159" class="Bound">pp</a> <a id="7327" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="7329" href="Number.html#7257" class="Bound">pp&#39;&#39;</a><a id="7333" class="Symbol">)</a>
   <a id="7338" class="Symbol">_</a> <a id="7340" class="Symbol">=</a> <a id="7342" href="Cubical.Foundations.Id.html#588" class="Function">refl</a> <a id="7347" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7349" href="Cubical.Foundations.Id.html#588" class="Function">refl</a>
   <a id="7357" class="Keyword">in</a> <a id="7360" class="Symbol">{! - [1ʳ]!}</a>


<a id="7374" href="Number.html#7374" class="UnsolvedMeta Function">_</a> <a id="7376" class="Symbol">=</a> <a id="7378" class="Symbol">{! ℕ!}</a>

<a id="7386" class="Comment">{-

distance : ∀(x y : [ℝ]) → [ℝ]
distance x y = max (x + (- y)) (- (x + (- y)))

IsCauchy : (x : ℕ → ℝ) → Type (ℓ-max ℓ&#39; ℚℓ)
IsCauchy x = ∀(ε : [ℚ⁺]) → ∃[ N ∈ ℕ ] ∀(m n : ℕ) → N ≤ⁿ m → N ≤ⁿ n → distance (x m) (x n) &lt; ε

-}</a>
</pre></body></html>