# Summary

## Questions from the video

- characterization of abs on ℂ
  - one property could be `iᶜ : ℝ → ℂ`, `|·|ᶜ : ℂ → ℝ` is such that `∀(x : ℂ) → | x |ᶜ ≡ | | x |ᶜ |ʳ`
  - but this is kind of weak and there have to be more properties
- characterization of `sqrt` on `ℝ₀⁺`
  - `√x · √x ≡ x` and `√(x · x) ≡ x`
  - use eulers algorithm as an "implementation" (because it is simple)
- disjointness does not need vice-versa, because `P → ¬Q` is equivalent to `Q → ¬P`
- Q: definitions of "ℝ or ℂ"
  - A: using R-modules should already leverage this

## immediate TODOs

- proof of `0 ≤ x → x < y → 0 < x + y` from sketch
- turn the 10 direct inclusions into 4 chained inclusions `ℕ↪ℤ`, `ℤ↪ℚ`, `ℚ↪ℝ`, `ℝ↪ℂ`
  - this should give difficult preservation properties of how the `abs` function interacts with inclusion into the complex numbers a single spot of occurence in `ℝ↪ℂ` and we need not to care about `ℤ↪ℂ` or similar
- since we want apartness `_#_` and absolute value function `abs` on all algebraic structures that are "backing" the number hierarchy, it'd be more sound to rename the `Semiring` into `ApartnessSemiring` or `ApartnessAbsSemiring`
  - or even skip all this and name it `ℕ-struct`
- the embedding from the standard library does not apply to types with structure but only to their carrier set
  - this becomes obvious, since a type with structure is a tuple and not a type
- a constructive characterization for the complex numbers that would be "compatible" to state facts about the abs function could be
  - ?? `∀(x : ℂ) → x # 0ᶜ → Σ[ r ∈ ℝ₀⁺ ] → ∃[ φ ∈ ℝ ] → x ≡ r · exp (i · φ)` ??
    - this is not a sufficient characterization because it does not chacacterize abs on all of ℂ
    - even if we'd add `abs 0 = 0` to it, still this would require splitting ℂ into two parts (zero and nonzero) to make a complete characterization which is not possible constructively
    - so we might add a continuity-characterization to it (i.e. `abs` is ε-δ-continuous) from which should follow `abs 0 = 0`
    - but still this is likely not the most elegant characterization
    - pitfall: define a notion of continuity on ℂ without making use of the absolute value function is tricky
  - this would be a "continuous" formulation and it made `x # 0ᶜ` and `φ ∈ ℝ` necessary
  - ?? how to define `exp`? ??
- Auke's chapter 8 gives metric spaces and pesudometric spaces
  - and complete metric spaces
- vector spaces can be formalized as R-modules
  - whith scalar multiplication being defined as a "ring over the space of linear endomorphisms of the carrier set"
  - and then we instance-proof an ℝ-module or a ℂ-module
  - it cannot be proven constructively that every finite dimenional vector space has a basis (i.e. we cannot constructively pick such a basis)
    - therefore we might add a `VectorSpaceWithBasis` that comes equipped with a basis already
- apartness on normed vector spaces from the norm: `x # 0ᵛ := || x ||ᵛ #ʳ 0ʳ` for the underlying ring
  - similar `x # y := || (x - y) ||ᵛ #ʳ 0ʳ`
- ?? are there "normed R-modules" then (for normed vector spaces)? ??
- `‹ x , x ›ᶜ ∈ ℝ` follows from conjugate symmetry of `‹_,_›ᶜ` and a property of `conjᶜ`
  - `∀ z → z ≡ conjᶜ z → Σ[ r ∈ ℝ ] ℝ↪ℂ r ≡ z`
    - and we should also have the back direction `∀ r → ℝ↪ℂ r ≡ conjᶜ (ℝ↪ℂ r)` which follows from preservation of `conj` along `ℝ↪ℂ` and that `congʳ = idʳ`

## facts and heuristics about constructive mathematics

- cauchy convergence on function spaces could be difficult
- there are several structure identity principles
- that some structure identity principle applies for a mathematical structure is a property of that structure (i.e. the SIP does not generally apply)
  - e.g. for topological spaces (in the classical definition) it does not apply
  - e.g. for fields it is also difficult, since `_¯¹` is only partially defined
- when the SIP from the Σ-theory applies, then we have that "structure preserving bijections" make "the" equivalences between two mathematical structures
  - this also means that for the mathematical structures for which this applies, we have that one does not need to care about the properties
    - the question of "whether the properties are preserved automatically" does not typecheck, i.e. it does not direcly make sense
    - but what it means, could be "whether it is possible to add any new (!) information/properties to a bijected structure when using the bijection that were not derivable before on the bijected structure alone"
      - ?? for "types with structure" this should not be the case ??
  - ?? we had some point about a difference of sets and types ??
- the "purpose" of SIP is to support the one-liner: "equality 'is' equivalence" (and vice-versa)
  - [Univalence](https://ncatlab.org/nlab/show/univalence+axiom): For any two types `X`, `Y`, this map `(X = Y) → (X ≃ Y)` is an equivalence.
  - (Cubical.Foundations.Id) `univalenceId : ∀ {ℓ} {A B : Type ℓ} → (A ≡ B) ≃ (A ≃ B)`
- subsets/subspaces
  - ?? embeddings "are" subspaces ??
  - ?? SIP minus one of the identities is an injection/embedding ??
  - "the" set theory is what we find in `Cubical.Foundations.Logic`
  - subsets are predicates (i.e. X → hProp where X isSet)
  - subspaces are spaces over subsets
- what is meant by "structure preserving" is straight forward for n-ary operations and n-ary relations
- constructive topology know a multitude of different formalizations, where classical topology is relatively clear-cut
- there are three separate things
  - the carrier set
  - the structure on the carrier set
    - ?? structure = n-ary operations and n-ary relations ??
  - and axioms for these
- we have `∀ x y → x # 0 → (x < y) ⨄ (y < x)` on ℚ and ℝ
  - and we have `¬(x # y) → x ≡ y` by tightness of `#`
  - and we have `x ≡ y → ¬(x # y)` by irreflexivity of `#`
- we have trichotomy `∀(q r : ℚ) → (q < r) ⨄ (q ≡ r) ⨄ (r < q)` on ℚ
  - therefore, we do have a linear order `∀ x → (x ≤ 0) ∨ (0 ≤ x)` on ℚ
  - linear order gives `∀ x y → (max x y ≡ x) ∨ (max x y ≡ y)`
  - without a linear order, we still have
    - `∀ x y z → (z < max x y) ⇔ (z < x) ∨ (z < y)`
    - `∀ x y z → (min x y < z) ⇔ (x < z) ∨ (y < z)`
- **we do NOT have trichotomy on ℝ**
  - in particular, we do NOT have `∀ x → x # 0 ⨄ x ≡ 0`
  - and we do NOT have a linear order on ℝ, since trichotomy implies the linear order
  - but we still have `x # 0 → (0 < x) ⨄ (x < 0)`
    - we do NOT have `∀ x → (abs x ≡ x) ∨ (abs x ≡ - x)`
    - but maybe we have `x # 0 → (abs x ≡ x) ⨄ (abs x ≡ - x)`
  - and we have cotransitivity `∀ x y z → x < y → (x < z) ∨ (z < y)`
    - which is similar in the sense that `∀ z ε → 0 < 0 + ε → (z < 0 + ε) ∨ (0 < z)` follows from it
    - or similar `∀ z → ∀ ε → 0 < ε → (z < ε) ∨ (0 < z)`
    - so `∀ ε → 0 < ε → (z < ε)` which is `¬(ε < z)` is somehow weaker than `z ≤ 0` which is `¬(0 < z)`
      - this is similar to item `R3.12` in [Bridges 1999]
  - and we have `∀ x → ¬(x < 0) → ¬(0 < x) → x ≡ 0` by antisymmetry of `<`
- some classical properties (that do not assume any structure classically) come with an additional structure in their constructive form (if there is a constructive form)
  - assuming an additional structure is "weaker" than not doing so
- we do not have just `IsCauchy` as a "property", we do have a `ModulusOfCauchyConvergence` as a "structure" for a given sequence
  - cauchy completeness then does not turn `IsCauchy`-sequences into limits, but sequence-modulus-pairs instead
- literature
  - (famous for the development are: Brouwer, Bishop (1967) and Bridges (1985))
  - [Bridges 1990 - Linear mappings are fairly well-behaved](https://link.springer.com/article/10.1007%2FBF01188684)
    - in the presence of completeness linear maps are well-behaved in our formal sense and have certain other aspects of good behaviour as well.
    - Let us agree that a linear mapping `T` between normed spaces is well-behaved if `T x ≠ 0` whenever `x ∈ E` is distinct from each element of `ker (T)`, the kernel of `T`.
    - (Note that when we say that two elements `x`, `y` of a metric space `(X, ρ)` are distinct, and we write `x ≠ y`, we mean that `ρ(x, y) > 0`.)
    - It is perhaps surprising that we cannot prove constructively that every bounded linear mapping `T : ℝ → ℝ`, is well-behaved.
    - For if we could do this, then, by considering mappings of the form `x ↦ ax` where `a ∈ ℝ` and `¬(a = 0)`, we would be able to prove the statement `∀ x ∈ ℝ → (¬(x = 0) ⇒ x ≠ 0)`, which is equivalent to Markov's principle:
      - if `(aₙ)` is a binary sequence such that `¬ (∀ n → (aₙ = 0))`, then there exists `n` such that `aₙ = 1`.
    - (Note, in passing, that Markov's principle implies constructively that every linear map between normed spaces is well-behaved.)
    - Although some constructive mathematicians are prepared to accept Markov's principle, most are not, and we remain unconvinced of the constructive validity of any proposition that entails it.
    - Theorem 1. A linear mapping of a normed space onto a Banach space is well-behaved.
    - A mapping f between metric spaces is said to be
      - one-one, if `f(x) = f(y)  ⇒  x = y`
      - strongly one-one, if `x ≠ y  ⇒  f(x) ≠ f(y)`
      - Corollary 0: A one-one linear map of a normed space onto a Banach space is strongly one-one
    - ... graph
    - ... some extensionality
    - linearly independent
    - metrically independent
  - [Bridges 1999 - Constructive mathematics: a foundation for computable analysis](https://core.ac.uk/download/pdf/82492373.pdf) has a section about "Constructive axioms for the real line"
    - (writes `x ≠ y` for `x # y`)
    - We identify the sets ℕ of natural numbers, ℕ⁺ of positive integers, ℤ of integers, and ℚ of rational numbers with the usual subsets of ℝ: for example we identify ℕ⁺ with `{n1 : n ∈ ℕ⁺}`
    - We assume that all relations and operations are extensional: for example, to say that the relation `>` is extensional means that if `x > y`, `x = x'`, and `y = y'`, then `x' > y'`.
    - `x ≠ y` iff (`x > y` or `y > x`)
    - `x > y` iff `∀ z → (y > z) ⇒ (x > z)`
    - R1. `R` is a Heyting field `∀(x y z : R)`
      - `x + y = y + x`
      - `(x + y) + z = x + (y + z)`
      - `0 + x = x`
      - `x + (- x) = 0`
      - `x · y = y · x`
      - `(x · y) · z = x · (y · z)`
      - `1 · x = x`
      - `x · x ⁻¹ = 1` if `x ≠ 0` (`¬(x = 0)` is not sufficient)
      - `x · (y + z) = x · y + x · z`
    - R2. Basic properties of `>` …
      - `¬((x < y) ∧ (y < x))`
      - `(x > y) ⇒ (∀ z → (x > z) ∨ (z > y))`
      - `¬(x ≠ y) ⇒ (x = y)`
      - `(x > y) ⇒ (∀ z → (x + z) > (y + z))`
      - `(x > 0) ∧ (y > 0) ⇒ (x · y > 0)`
    - the notions _bounded above_, _bounded below_, and _bounded_ are defined as in classical mathematics
      - e.g. if `S` is a _nonempty_ subset of ℝ that is bounded above, then its _least upper bound_, if it exists, is the unique real number `b` such that
        - `b` is an upper bound of `S`, and
        - for each `b' < b` there exists `s ∈ S` such that `s > b'`.
        - ?? `supremum S = Σ[ b ∈ S ] (IsUpperBound S b) × (∀ b' → b' < b → ∃[ s ∈ S ] b' < s)` ??
      - (Note that nonempty means what the intuitionists call "inhabited"; that is, we can construct an element of the set in question.)
    - R3. Special properties of `>` …
      - `¬(x > x)`
      - `x ≥ x`
      - `(x > y) ∧ (y > z) ⇒ x > z`
      - `¬((x > y) ∧ (y ≥ x))`
      - `(x > y ≥ z) ⇒ (x > z)`
      - `(x ≥ y > z) ⇒ (x > z)`
      - `¬(x > y) ⇔ (y ≥ x)`
      - `¬(x ≥ y) ⇔ ¬¬(y > x)`
      - `(x ≥ y ≥ z) ⇔ (x ≥ z)`
      - `(x ≥ y) ∧ (y ≥ x) ⇒ (x = y)`
      - `¬((x > y) ∧ (x = y))`
      - `(x ≥ 0) ⇒ ((x = 0) ⇔ (∀(ε > 0) → (x < ε)))`
      - `(x + y > 0) ⇒ (x > 0) ∨ (y > 0)`
      - `(x > 0) ⇒ (- x < 0)`
      - `(x > y) ∧ (z < 0) ⇒ (y · z > x · z)`
      - `(x ≠ 0) ⇒ x² > 0`
      - `1 > 0`
      - `x² ≥ 0`
      - `(0 < x < 1) ⇒ (x > x²)`
      - `(- 1 < x < 1) ⇒ ¬((x² > x) ∧ (x² > - x))`
      - `(x² > 0) ⇒ (x ≠ 0)`
      - `(x > 0) ⇒ (x ⁻¹ ≥ 0)`
      - `∀ m m' n n' → 0 < n → 0 < n' → (m / n > m' / n') ⇔ (m · n' > m' · n)`
      - `∀(n ∈ ℕ⁺) → (n ⁻¹ > 0)`
      - `x > 0 → y ≥ 0 → ∃[ n ∈ ℤ ] n · x > y`
      - `(x > 0) ⇒ (x ⁻¹ > 0)`
      - `(x · y > 0) ⇒ (x ≠ 0) ∧ (y ≠ 0)`
      - `∀(x > 0) → ∃[ n ∈ ℕ⁺ ] x < n < x + 2`
      - `∀ a b → a < b → ∃[ q ∈ ℚ ] a < r < b`
  - [Bridges 2006 - Techniques of Constructive Analysis](https://books.google.de/books?id=H5BEsaM9XQcC) seems to have a chapter about Hilbert spaces which also defines adjoints
  - [Diener 2008 - Compactness Under Constructive Scrutiny](http://ir.canterbury.ac.nz/bitstream/handle/10092/1823/thesis_fulltext.pdf?sequence=1) has a chapter about "Differentiable manifolds"
  - [Richman 2007 - Real numbers and other completions](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.145.454&rep=rep1&type=pdf) writes about
    - completeness of metric spaces,
    - axioms for the real numbers, and a construction of the real numbers that is appropriate for those axioms.
  - [Seminar "Konstruktive Analysis 2019" von Helmut Schwichtenberg](http://www.mathematik.uni-muenchen.de/~schwicht/seminars/semws19/index.php)
    - [Schwichtenberg 2019 - Constructive analysis with witnesses](http://www.mathematik.uni-muenchen.de/~schwicht/seminars/semws19/constr19.pdf)
      - defines real numbers as sequence-modulus-pairs
        - uses `1 / 2ᵖ` for `ε`, depending on `p`
      - starts directly with "1.1. Approximation of square roots"
      - has metric spaces, normed spaces, ordinary differential equations

## further development and theory

- assuming a lot of given structure to work with
  - e.g. multivalued piecewise continuous functions over a simplicial complex
    - this makes a functions argument into a tuple of a cell AND a coordinate within that cell
    - ?? we might then add a `coincides` relation that relates these points of different cells that "are" the same point ??
    - ?? what about the interior of a set? it could be in the theory that the cell complex is defined as mapping only the interior of a cell ??
    - ?? how to define interior if it becomes necessary ??
  - allowing set operations only on cell-granulariy (e.g. cutting a complex, splitting a complex)

## next up

- space hierarchy
  - vector space = R-module
  - normed vector space = normed R-module (assumes norm)
    - needs a "normed ring" as a backing algebraic structure
  - banach space = complete normed vector space
  - inner product space = vector space + inner product (gives norm and metric)
    - use inner product R-modules instead
    - see discussion
  - hilbert space = complete inner product space
  - euclidean space = finite-dimensional inner product space over the real numbers
    - Q: how to define "finite-dimensional space" ?
      - A: demand a given basis
    - use inner-product-R-module-with-Basis
  - ℝⁿ as an instance of euclidean space
- formalizing chapter 3 of Arnold's book
  - and "Box 2.1." on p. 19


- structure (structure in brackets () can be defined in terms of other structure)
  - struct = basic algebraic structure to start out
    - Semiring = `_+_` + `_·_`
    - Ring     = `_+_` + `_·_` + `-_`
    - Field    = `_+_` + `_·_` + `-_` + `_⁻¹`
  - apart  = assume an apartness relation
  - abs    = assume an absolute value function
  - order  = assume an order (linear or partial)
  - cauchy = assume limits of sequence-modulus pairs (from a sequence-modulus pair (x, M), we can compute a limit of x.)
  - sqrt₀⁺ = assume a square root function on nonnegative numbers
  - exp    = assume an exponential function

| name | struct              | apart | abs | order | cauchy | sqrt₀⁺  | exp | final name                                                 |
|------|---------------------|-------|-----|-------|--------|---------|-----|------------------------------------------------------------|
| ℕ    | Semiring            |  (✓)  | (✓) | lin.  |        | (on x²) |     | LinearlyOrderedSemiring                                    |
| ℤ    | Ring                |  (✓)  | (✓) | lin.  |        | (on x²) |     | LinearlyOrderedRing                                        |
| ℚ    | Field               |  (✓)  | (✓) | lin.  |        | (on x²) | (✓) | LinearlyOrderedField                                       |
| ℝ    | Field               |  (✓)  | (✓) | part. |   ✓    |    ✓    | (✓) | CompletePartiallyOrderedFieldWithSqrt                      |
| ℂ    | euclidean 2-Product |  (✓)  | (✓) |       |  (✓)   |         |  ?  | EuclideanTwoProductOfCompletePartiallyOrderedFieldWithSqrt |
| R    | Ring                |   ✓   |  ✓  |       |        |         |  ?  | ApartnessRingWithAbs                                       |
| G    | Group               |   ✓   |  ✓  |       |        |         |  ?  | ApartnessGroupWithAbs                                      |
| K    | Field               |   ✓   |  ✓  |       |   ✓    |         |  ?  | CompleteApartnessFieldWithAbs                              |

- numbers
  - (Ordered ⇒ Apartness and WithAbs)
  - (order ⇒ (trichotomy ⇔ linear order))
  - ([A Heyting field ... is essentially a field with an apartness relation](https://en.wikipedia.org/wiki/Heyting_field))
    - A commutative ring is a Heyting field if `¬(0 ≡ 1)`, either `a` or `1 - a` is invertible for every `a`, and each noninvertible element is zero.
    - The first two conditions say that the ring is local; the first and third conditions say that it is a field in the classical sense.
    - The apartness relation is defined by writing `a # b` if `a - b` is invertible.
    - This relation is often now written as `a ≠ b` with the warning that it is not equivalent to `¬(a ≡ b)`.
    - For example, the assumption `¬(a ≡ 0)` is not generally sufficient to construct the inverse of `a`, but `a ≠ 0` is.
  - ([Crvenković 2013 - Semigroups with apartness](https://onlinelibrary.wiley.com/doi/abs/10.1002/malq.201200107))
  - `d(q,r) = | q - r | = max (q - r) (r - q) = sqrt ((q - r) ²)`
  - ℕ isa LinearlyOrderedSemiring (has sqrt on squares of nonnegative numbers)
  - ℤ isa LinearlyOrderedRing (has sqrt on squares of nonnegative numbers)
  - ℚ isa LinearlyOrderedField (has sqrt on squares of nonnegative numbers)
  - ℝ isa CompletePartiallyOrderedField (has sqrt on nonnegative numbers)
  - ℂ isa CompleteApartnessFieldWithAbs
  - ℂ isa EuclideanTwoProductOfCompletePartiallyOrderedField (with euclidean metric)
  - ℕ↪ℂ works on ApartnessSemiringWithAbs
  - ℤ↪ℂ works on ApartnessRingWithAbs
  - ℚ↪ℂ works on ApartnessFieldWithAbs
  - ℝ↪ℂ works on CompleteApartnessFieldWithAbs
- spaces
  - basic algebraic (use standard library)
    - Semiring
    - Ring
    - Field
  - modules
    - R-module
    - G-module = R-module + R is also a Group
    - K-module = K-module + R is a complete field (ℝ or ℂ)
    - normed K-module = K-module + norm
  - spaces on-top of K-modules (over a complete field)
    - (inner product ⇒ euclidean metric)
    - vector space = K-module
    - finite-dimensional vector space = K-module + basis
    - normed vector space = K-module + norm
    - finite-dimensional normed vector space = K-module + norm + basis
    - complete normed vector space (banach) = K-module + norm + modulus of cauchy convergence
    - inner product space = K-module + inner product
    - complete inner product space (hilbert) = K-module + inner product + modulus of cauchy convergence
    - finite dimensional inner product space
  - other spaces
    - metric space = set + metric
    - affine space = set + vector space + free action of the additive group of the vector space on the set

- notions
  - ε-δ-continuity
  - cauchy convergence
  - cauchy completeness = Σ-limit (we can pick a limit)
    - is not only a property, but comes with a structure: modulus of cauchy convergence
  - limit of a cauchy sequence
  - compact = cauchy complete + totally bounded
  - closed (subset) = closed under limits (contains its limits)

- structure (structure in brackets () can be defined in terms of other structure)
  - (metric ⇒ notion of ε-δ-continuity)
  - (notion of continuity ⇒)
  - carrier = type that isSet
  - module  = which module to use over the carrier
  - metric  = assume a metric
  - norm    = assume a norm
  - inner   = assume an inner product
  - basis   = assume a finite dimensional basis
  - cauchy  = assume limits of sequence-modulus pairs (from a sequence-modulus pair (x, M), we can compute a limit of x.)

| name                                    | carrier | module | metric | norm | inner | basis | cauchy |
|-----------------------------------------|---------|--------|--------|------|-------|-------|--------|
| VectorSpace                             |   any   |   K    |        |      |       |       |        |
| FiniteDimVectorSpace                    |   any   |   K    |        |      |       |   ✓   |        |
| NormedVectorSpace                       |   any   |   K    |   (✓)  |   ✓  |       |       |        |
| FiniteDimNormedVectorSpace              |   any   |   K    |   (✓)  |   ✓  |       |   ✓   |        |
| CompleteNormedVectorSpace               |   any   |   K    |   (✓)  |   ✓  |       |       |   ✓    |
| FiniteDimCompleteNormedVectorSpace      |   any   |   K    |   (✓)  |   ✓  |       |   ✓   |   ✓    |
| InnerProductSpace                       |   any   |   K    |   (✓)  |  (✓) |   ✓   |       |        |
| FiniteDimInnerProductSpace              |   any   |   K    |   (✓)  |  (✓) |   ✓   |   ✓   |        |
| CompleteInnerProductSpace               |   any   |   K    |   (✓)  |  (✓) |   ✓   |       |   ✓    |
| FiniteDimCompleteInnerProductSpace      |   any   |   K    |   (✓)  |  (✓) |   ✓   |   ✓   |   ✓    |
| FiniteDimCompleteInnerProductSpaceOverℝ |    ℝ    |   ℝ    |   (✓)  |  (✓) |   ✓   |   ✓   |   ✓    |

- EuclideanSpace        = FiniteDimCompleteInnerProductSpaceOverℝ
- BanachSpace           = CompleteNormedVectorSpace
- FiniteDimBanachSpace  = FiniteDimCompleteNormedVectorSpace
- HilbertSpace          = CompleteInnerProductSpace
- FiniteDimHilbertSpace = FiniteDimCompleteInnerProductSpace

- Isabelle's `(abs_le_iff)` means that `abs` is defined as `max(x, -x)`
- replace ≤ with < for constructive assumption
- take [Booij 2020] definition of metric space
- there is an article about [(archimedean) absolute value functions](https://ncatlab.org/nlab/show/absolute+value) on the nLab
  - we cannot constructively prove that `(| x | ≡ x) ∨ (| x | ≡ - x)`
  - we have `x # 0 → 0 < x ⨄ x < 0`, so maybe we have `x # 0 → (| x | ≡ x) ∨ (| x | ≡ - x)`
- there is an article about [archimedean valued fields](https://ncatlab.org/nlab/show/archimedean+valued+field) on the nLab
- there is an article about [square roots](https://ncatlab.org/nlab/show/square+root) on the nLab
  - what about `max x = sqrt (x · x)`
- for rings (ℤ), there seems to be [a hierarchy](https://en.wikipedia.org/wiki/Integral_domain)
  - rngs
  - ⊃ rings
  - ⊃ commutative rings
  - ⊃ integral domains
  - ⊃ integrally closed domains
  - ⊃ GCD domains
  - ⊃ unique factorization domains
  - ⊃ principal ideal domains
  - ⊃ Euclidean domains
  - ⊃ fields
  - ⊃ algebraically closed fields
- A [rig](https://ncatlab.org/nlab/show/rig) is a ring ‘without negatives'
- The term ["rng"](https://en.wikipedia.org/wiki/Rng_(algebra)) (pronounced rung) is meant to suggest that it is a "ring" without "i", i.e. without the requirement for an "identity element".

## Pathes (`_≡_`, `Path`, `PathP`), Identity (`Id`), two kinds of Equivalences (`_≃_`) and Isomorphisms (`Iso`)

- there four notions are binary "operations" on types that come in constant / homogeneous variants and depenedent / heterogeneous variants
  - _"The central notion of equality in Cubical Agda is hence heterogeneous equality (in the sense of PathOver in HoTT)."_ (see [manual](https://agda.readthedocs.io/en/v2.6.0/language/cubical.html))
  - heterogeneous equality is already available in non-cubical agda

| notion       | homogeneous | heterogeneous | Agda module |
|--------------|-------------|---------------|-------------|
| PathP        | `_≡_ {A = A} = PathP (λ i → A)` | `PathP : ∀ {ℓ} (A : I → Set ℓ) → A i0 → A i1 → Set ℓ`  | Agda.Builtin.Cubical.Path |
| Identity     | `postulate Id : ∀ {ℓ} {A : Set ℓ} → A → A → Set ℓ` |     | Agda.Builtin.Cubical.Id |
| Equivalence¹ | | `A ≃ B = Σ[ f ∈ (A → B) ] isEquiv f`⁽¹⁾                   | Agda.Builtin.Cubical.Glue |
| Isomorphism  | | `Iso = f + f⁻¹ + (section f f⁻¹) + (retraction f f⁻¹)` | Cubical.Foundations.Isomorphism |
| Equivalence² | | `A ≃ B = Σ[ f ∈ (A → B) ] isEquiv f`                   | Cubical.Foundations.Id |

- ⁽¹⁾ `Σ-syntax` is not yet defined in (Agda.Builtin.Cubical.Glue) therefore this is really the unsugared version
- (Cubical.Core.Primitives) defines `Path A a b = PathP (λ _ → A) a b` which is almost `_≡_` from (Agda.Builtin.Cubical.Path)

- there is also "definitional equality" of "canonical terms" (normalized terms)
  - and there is "definitional equality" of non-normalized / un-normalizable terms to some degree
- notions of equality come with eliminators, but to some extent we have pattern matching for non-cubical `refl`
  - do we have a similar thing in cubical agda?
- Pathes and `Id` are somehow builtin, where Isomorphisms and Equivalences are defined on-top
  - are they all `isProp`?
  - `PathP (λ i → A) x y` gets printed as `x ≡ y` when `A` does not mention `i` (Cubical.Core.Primitives)
  - `postulate Id : ∀ {ℓ} {A : Set ℓ} → A → A → Set ℓ`                           (Agda.Builtin.Cubical.Id)
  - `A ≃ B = Σ[ f ∈ (A → B) ] isEquiv f` (a function and an equivalence-proof of it) (Cubical.Foundations.Id)
    - both, (Agda.Builtin.Cubical.Glue) and (Cubical.Foundations.Id) define `_≃_`, (but in a definitionally equal way ?)
      - (Cubical.Foundations.Id) is "on-top" of (Cubical.Foundations.Equiv)
      - this might be for better Have/Goal normalization (?)
      - `_≃_` from (Cubical.Foundations.Equiv) is called `EquivPath` in (Cubical.Foundations.Id)
    - `isEquiv f = ∀ y → isContr (fiber f y)` (all fibers are contractible) (Cubical.Foundations.Id)
    - `isContr A = Σ[ x ∈ A ] ∀ y → x ≡ y` (there exists a point that is equal to all other points) (Cubical.Foundations.Id)
    - `fiber {A = A} f y = Σ[ x ∈ A ] f x ≡ y` (the "fiber over y" is the "inverse image of a singleton `{y}`" (because "inverse image" is defined also for non-singleton sets)) (Cubical.Foundations.Id)
  - `Iso = f + f⁻¹ + (section f f⁻¹) + (retraction f f⁻¹)` (`f` is a section and `f⁻¹` is a retraction) (Cubical.Foundations.Isomorphism)
    - `section f f⁻¹ = ∀ b → f   (f⁻¹ b) ≡ b` (`f` is a section of `f⁻¹`) (Cubical.Foundations.Isomorphism)
    - `retract f f⁻¹ = ∀ a → f⁻¹ (f   a) ≡ a` (`f⁻¹` is a retraction of `f`) (Cubical.Foundations.Isomorphism)
- one can convert all (?) of them into each other
  - `isoToEquiv     : Iso A B → A ≃ B`                                       (Cubical.Foundations.Isomorphism)
  - `equivToIso     : ∀ {ℓ ℓ'} {A : Type ℓ} {B : Type ℓ'} → A ≃ B → Iso A B` (Cubical.Foundations.Equiv)
  - `isoToPath      : Iso A B → A ≡ B`                                       (Cubical.Foundations.Isomorphism)
  - `pathToIso      : ∀ {ℓ} {A B : Type ℓ} → A ≡ B → Iso A B`                (Cubical.Foundations.Transport)
  - `pathToEquiv    : {ℓ : I → Level} (P : (i : I) → Set (ℓ i)) → A ≃ B`     (Cubical.Foundations.Isomorphism)
  - `transportEquiv : ∀ {ℓ} {A B : Type ℓ} → A ≡ B → A ≃ B`                  (Cubical.Foundations.Transport)
  - what about `equivToPath` ?
  - `idToPath : ∀ {x y : A} → Id x y → Path _ x y` (Cubical.Foundations.Id)
  - `pathToId : ∀ {x y : A} → Path _ x y → Id x y` (Cubical.Foundations.Id)
- Univalence
  - `path≡Id : ∀ {ℓ} {A B : Type ℓ} → Path _ (Path _ A B) (Id A B)`           (Cubical.Foundations.Id)
  - `equivPath≡Equiv : ∀ {ℓ} {A B : Type ℓ} → Path _ (EquivPath A B) (A ≃ B)` (Cubical.Foundations.Id)
  - `univalenceId : ∀ {ℓ} {A B : Type ℓ} → (A ≡ B) ≃ (A ≃ B)`                 (Cubical.Foundations.Id)
